{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Learn WebAssembly with twr-wasmDocumentation and Examples","text":""},{"location":"#easier-cc-webassembly","title":"Easier C/C++ WebAssembly","text":"<p>Version 2.1.1</p> <p>twr-wasm is a simple, lightweight and easy to use library for building C/C++ WebAssembly code directly with clang. It solves some common use cases with less work than the more feature rich emscripten. </p> <p>twr-wasm is easy to understand, and has some great features. You can call blocking functions. You can input and print streaming character i/o to a <code>&lt;div&gt;</code> tag, use a <code>&lt;canvas&gt;</code> element as an ANSI terminal, and use 2D drawing apis (that are compatible with JavaScript Canvas APIs) to draw to a <code>&lt;canvas&gt;</code> element. </p> <p>twr-wasm allows you to run C/C++ code in a web browser. Legacy code, libraries, full applications, or single functions can be integrated with JavaScript and TypeScript.</p> <p>twr-wasm is designed to be used with the standard llvm clang compiler and tools.</p> <p>twr-wasm was previously named tiny-wasm-runtime.</p>"},{"location":"#live-webassembly-examples-and-source","title":"Live WebAssembly Examples and Source","text":"Name View Live Link Source Link Bouncing Balls (C++) View bouncing balls Source for balls Maze Gen/Solve (Win32 C Port) View live maze Source for maze Input/Output with <code>&lt;div&gt;</code> View square demo Source Mini-Terminal (hello world using <code>&lt;canvas&gt;</code>) View demo Source CLI using libc++ and <code>&lt;canvas&gt;</code>) View console Source"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>compile and link C/C++ for use with WebAssembly using clang directly</li> <li>standard C library, libc++. and purpose built APIs available from C/C++</li> <li>TypeScript/JavaScript classes to load Wasm modules and call C/C++ functions</li> <li>localization support, UTF-8, and windows-1252 support</li> <li>in C/C++, print and get characters to/from <code>&lt;div&gt;</code> tags in your HTML page</li> <li>in C/C++, print and get characters to/from a <code>&lt;canvas&gt;</code> based \"terminal\"</li> <li>in C/C++ use 2D drawing API compatible with JavaScript Canvas</li> <li>in C/C++, use the \"blocking loop\" pattern and integrate with Javascript's asynchronous event loop</li> </ul>"},{"location":"#hello-world","title":"Hello World","text":"<p>Here is the simplest <code>twr-wasm</code> example.</p> helloworld.c<pre><code>#include &lt;stdio.h&gt;\n\nvoid hello() {\n    printf(\"hello, world!\\n\");\n}\n</code></pre> index.html<pre><code>&lt;head&gt;\n   &lt;title&gt;Hello World&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n   &lt;div id=\"twr_iodiv\"&gt;&lt;/div&gt;\n\n   &lt;script type=\"module\"&gt;\n      import {twrWasmModule} from \"twr-wasm\";\n\n      const mod = new twrWasmModule();\n      await mod.loadWasm(\"./helloworld.wasm\");\n      await mod.callC([\"hello\"]);\n   &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"#on-github","title":"On Github","text":"<p>https://github.com/twiddlingbits/twr-wasm</p>"},{"location":"#why","title":"Why?","text":"<p>The Wasm Runtime Limitations section explains why a library like twr-wasm is needed to use WebAssembly.</p>"},{"location":"#version-2-vs-1","title":"Version 2 vs. 1","text":"<ul> <li>libc++ built for WebAssembly is included</li> <li>most of the standard C library is now implemented</li> <li>instructions for WebAssembly C/C++ source level debugging</li> <li>version of library with debug symbols provided</li> <li>locale, UTF-8, and windows-1252 support</li> </ul>"},{"location":"#version-2-limitations","title":"Version 2 Limitations","text":"<ul> <li>libc++ not built with exceptions enabled</li> <li>some standard C library functions are not 100% implemented</li> <li>Designed to work with a browser.  Not tested with or designed to work with node.js  </li> <li>Not all of compile-rt is ported (but most bits you need are)</li> <li>The following non-compatible changes since 1.0 (relatively minor)<ul> <li>there is no longer 'twr_' prefixed std c lib functions (use the normal std c lib names)</li> <li>most 'twr_wasm_' prefixed functions have been shortened to 'twr_'.  </li> <li>some functions were renamed or changed slightly to be more consistent, but no functionality is lost.</li> </ul> </li> </ul>"},{"location":"#post-feedback","title":"Post Feedback","text":"<p>Please post feedback (it worked for you, didn't work, requests, questions, etc) at https://github.com/twiddlingbits/twr-wasm/</p>"},{"location":"api/api-c-con/","title":"WebAssembly Console API","text":"<p>twr-wasm for WebAssembly provides a console API for abstracting I/O.  This console API is used by stdin, stdout, and stderr, as well as the ANSI Terminal.  Streaming and Windowed I/O is supported.</p> <p>This section describes the C character based input/output console API this is abstracted by <code>struct IoConsole</code>.  </p> <p>Consoles can be \"tty\" aka \"streamed\", or they can be \"windowed\" (aka a \"terminal\").  </p> <p>Also see stdio</p>"},{"location":"api/api-c-con/#examples","title":"Examples","text":"Name View Live Link Source Link \"terminal\" in/out with a <code>&lt;canvas&gt;</code> View mini-term demo Source"},{"location":"api/api-c-con/#getting-stderrstdin-stdout","title":"Getting stderr,stdin, stdout","text":"<p>stdio.h defines <code>stdin</code>, <code>stdout</code>, <code>stderr</code> as explained here: stdio</p> <p>stdio.h also defines <code>FILE</code> like this: <pre><code>typedef struct IoConsole FILE; \n</code></pre></p> <p>from <code>&lt;stdio.h&gt;</code>: <pre><code>#define stderr (FILE *)(twr_get_stderr_con())\n#define stdin (FILE *)(twr_get_stdio_con())\n#define stdout (FILE *)(twr_get_stdio_con())\n</code></pre></p>"},{"location":"api/api-c-con/#getting-a-new-console","title":"Getting a new console","text":"<p>stdin and stdout are set as explaind here.   However, in unusual cases you might want to access the various consoles directly, regardless of how stdin, stdout, or stderr are set.  You can do so like this:</p>"},{"location":"api/api-c-con/#io_nullcon","title":"io_nullcon","text":"<p>Returns an IoConsole that goes to the bit bucket.  io_getc32 will return 0.</p> <pre><code>#include \"twr-io.h\"\n\nstruct IoConsole* io_nullcon(void);\n</code></pre>"},{"location":"api/api-c-con/#twr_debugcon","title":"twr_debugcon","text":"<p>Returns an IoConsole that goes to the browser's debug console.</p> <pre><code>#include \"twr-crt.h\"\n\nstruct IoConsole* twr_debugcon(void);\n</code></pre>"},{"location":"api/api-c-con/#twr_divcon","title":"twr_divcon","text":"<p>Returns an IoConsole that goes to <code>&lt;div id=\"twr_iodiv\"&gt;</code>, if it exists.</p> <pre><code>#include \"twr-crt.h\"\n\nstruct IoConsole* twr_divcon(void);\n</code></pre>"},{"location":"api/api-c-con/#twr_windowcon","title":"twr_windowcon","text":"<p>Returns an IoConsole that goes to <code>&lt;canvas id=\"twr_iocanvas\"&gt;</code> , if it exists. </p> <p>NOTE: Only one call can be made to this function, and it is usually made by the twr-wasm C runtime, so you likely won't call this function.</p> <pre><code>#include \"twr-crt.h\"\n\nstruct IoConsole* twr_windowcon(void);\n</code></pre>"},{"location":"api/api-c-con/#io-console-functions","title":"IO Console Functions","text":""},{"location":"api/api-c-con/#io_putc","title":"io_putc","text":"<p>Sends a byte to an IoConsole and supports the current locale's character encoding.    This function will \"stream\" using the current code page.  In other words, if you <code>io_putc</code> ASCII, it will work as \"normal\".  If the current locale is set to 1252, then you can send windows-1252 encoded characters.  If the current locale is UTF-8, then you can stream UTF-8 (that is, call <code>io_putc</code> once for each byte of the multi-byte UTF-8 character).</p> <p>Note that when characters are sent to the browser console using <code>stderr</code> they will not render to the console until a newline, return, or ASCII 03 (End-of-Text) is sent.</p> <pre><code>#include \"twr-io.h\"\n\nvoid io_putc(struct IoConsole* io, unsigned char c);\n</code></pre>"},{"location":"api/api-c-con/#io_putstr","title":"io_putstr","text":"<p>Calls <code>io_putc</code> for each byte in the passed string.</p> <pre><code>#include \"twr-io.h\"\n\nvoid io_putstr(struct IoConsole* io, const char* s);\n</code></pre>"},{"location":"api/api-c-con/#io_printf","title":"io_printf","text":"<p>Identical to <code>fprintf</code>, however io_printf will call <code>io_begin_draw</code> and <code>io_end_draw</code> around its drawing activities -- resulting in snapper performance.</p> <p>For example: <pre><code>#include \"twr-io.h\"\n\nio_printf(twr_debugcon(), \"hello over there in browser debug console land\\n\");\n</code></pre></p> <p>or</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;twr_io.h&gt;\n\nio_printf(stdout, \"hello world\\n\");\n</code></pre> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_printf(struct IoConsole *io, const char *format, ...);\n</code></pre>"},{"location":"api/api-c-con/#io_getc32","title":"io_getc32","text":"<p>Waits for the user to enter and then returns a unicode code point. Currently only really works with an IoConsole that is stdin.</p> <p>To return characters encoded with the current locale, see <code>io_mbgetc</code></p> <pre><code>#include &lt;twr_io.h&gt;\n\nint io_getc32(struct IoConsole* io);\n</code></pre>"},{"location":"api/api-c-con/#io_mbgetc","title":"io_mbgetc","text":"<p><code>io_mbgetc</code> will get a character from stdin and encode it using the character encoding of the LC_CTYPE category of the current locale.  \"C\" will use ASCII.  UTF-8 and windows-1252 are also supported.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_mbgetc(struct IoConsole* io, char* strout);\n</code></pre>"},{"location":"api/api-c-con/#io_mbgets","title":"io_mbgets","text":"<p>Gets a string from an IoConsole (which needs to be stdin).  Returns when the user presses \"Enter\".  Displays a cursor character and echos the inputted characters, at the current cursor position. Uses character encoding of LC_TYPE of current locale.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nchar *io_mbgets(struct IoConsole* io, char *buffer );\n</code></pre>"},{"location":"api/api-c-con/#io_get_cursor","title":"io_get_cursor","text":"<p>Returns an integer of the current cursor position.  The cursor is where the next io_putc is going to go. </p> <p>For windowed consoles, the cursor position ranges from [0, width*height-1], inclusive.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nint io_get_cursor(struct IoConsole* io);\n</code></pre>"},{"location":"api/api-c-con/#io_set_colors","title":"io_set_colors","text":"<p>For windowed consoles only.</p> <p>Sets a 24 bit RGB default color for the foreground and background.  The prior default colors are changed (lost).  For example, if you set the default colors when you created the window (see stdio), the defaults will no longer be active.  Use <code>io_get_colors</code> to save existing colors for later restoration using <code>io_set_colors</code>.</p> <p>A call to <code>io_set_colors</code> doesn't actually cause any on screen changes.  Instead, these new default colors are used in future draw and text calls.  A foreground and background color is set for each cell in the console window.  The cell's colors are set to these default foreground/background colors when a call to <code>io_setc</code>, <code>io_setreset</code>, etc is made.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_set_colors(struct IoConsole* io, unsigned long foreground, unsigned long background);\n</code></pre>"},{"location":"api/api-c-con/#io_get_colors","title":"io_get_colors","text":"<p>For windowed consoles only.</p> <p>Gets the current default colors.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_get_colors(struct IoConsole* io, unsigned long *foreground, unsigned long *background);\n</code></pre>"},{"location":"api/api-c-con/#io_cls","title":"io_cls","text":"<p>For windowed consoles only.</p> <p>Clears the screen.  That is, all character cells in the window are set to a space, their colors are reset to the current default colors (see <code>io_set_colors</code>).</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_cls(struct IoConsoleWindow* iow);\n</code></pre>"},{"location":"api/api-c-con/#io_setc","title":"io_setc","text":"<p>For windowed consoles only.</p> <p>Sets a window cell to a character.  Sends a byte to an IoConsole and supports the current locale's character encoding.    This function will \"stream\" using the current code page.  In other words, if you <code>io_setc</code> ASCII, it will work as \"normal\".  If the current locale is set to 1252, then you can send windows-1252 encoded characters.  If the current locale is UTF-8, then you can stream UTF-8 (that is, call <code>io_setc</code> once for each byte of the multi-byte UTF-8 character).</p> <pre><code>#include &lt;twr_io.h&gt;\n\nbool io_setc(struct IoConsoleWindow* iow, int location, unsigned char c);\n</code></pre>"},{"location":"api/api-c-con/#io_setc32","title":"io_setc32","text":"<p>For windowed consoles only.</p> <p>Sets a window cell to a unicode code point.  The colors are set to the defaults (see <code>io_set_colors</code>).</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_setc32(struct IoConsoleWindow* iow, int location, int c);\n</code></pre>"},{"location":"api/api-c-con/#io_setreset","title":"io_setreset","text":"<p>For windowed consoles only.</p> <p>Sets or resets (clears) a chunky graphics \"pixel\".  Each character cell can also be a 2x3 grid of graphic \"pixels\".  In other words, the terminal window has pixel dimensions of width2 x height3.</p> <p>The color will be set to the defaults if the impacted cell is not a graphics cell.  If it is an existing graphics cell, the colors don't change.</p> <p>See the <code>stdio-canvas</code> example.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nbool io_setreset(struct IoConsoleWindow* iow, int x, int y, bool isset);\n</code></pre>"},{"location":"api/api-c-con/#io_point","title":"io_point","text":"<p>For windowed consoles only.</p> <p>Checks if a chunky graphics \"pixel\" is set or clear.  See <code>io_setreset</code>.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nbool io_point(struct IoConsoleWindow* iow, int x, int y);\n</code></pre>"},{"location":"api/api-c-con/#io_set_cursor","title":"io_set_cursor","text":"<p>Moves the cursor.  See <code>io_get_cursor</code>.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_set_cursor(struct IoConsoleWindow* iow, int loc);\n</code></pre>"},{"location":"api/api-c-con/#io_begin_draw","title":"io_begin_draw","text":"<p>For windowed consoles only.</p> <p>This call (and its matching io_end_draw) are not required.  But if you bracket any call sequence that draws to the terminal window with an <code>io_begin_draw</code> and <code>io_end_draw</code>, the updates will be batched into one update.  This will increase performance and usually prevents the user from seeing partial updates.</p> <p><code>io_begin_draw</code> can be nested. </p> <p>See the stdio-canvas example.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_begin_draw(struct IoConsole* io);\n</code></pre>"},{"location":"api/api-c-con/#io_end_draw","title":"io_end_draw","text":"<p>For windowed consoles only.</p> <p>See <code>io_begin_draw</code>.</p> <pre><code>#include &lt;twr_io.h&gt;\n\nvoid io_end_draw(struct IoConsole* io);\n</code></pre>"},{"location":"api/api-c-d2d/","title":"2D Draw C API for WebAssembly","text":"<p>This section describes twr-wasm's C D2D API, which allows your WebAssembly module to call many of the JavaScript Canvas APIs.  There is also a C++ canvas wrapper class in the balls example.</p>"},{"location":"api/api-c-d2d/#examples","title":"Examples","text":"Name View Live Link Source Link Bouncing Balls (C++) View bouncing balls Source for balls Maze (Win32 C Port) View live maze here Source for maze"},{"location":"api/api-c-d2d/#overview","title":"Overview","text":"<p>Add a canvas tag to your HTML named <code>twr_d2dcanvas</code> like this example (you can use any width/height you like):</p> <pre><code>&lt;canvas id=\"twr_d2dcanvas\" width=\"600\" height=\"600\"&gt;&lt;/canvas&gt;\n</code></pre> <p>To draw using the C 2D Draw API:</p> <ul> <li>call d2d_start_draw_sequence()</li> <li>call draw commands, like d2d_fillrect()</li> <li>call d2d_end_draw_sequence()</li> </ul> <p>Commands are queued until flushed, which will take the batch of queued draw commands, and execute them.  In the case of twrWasmModuleAsync, the batch of commands is sent over to the JavaScript main thread for execution. By batching the calls, performance is improved.</p> <p>Flush() waits for the commands to finish execution before returning.  Flush() is called automatically by d2d_end_draw_sequence() and so you generally don't need to call it manually.</p> <p>You pass an argument to d2d_start_draw_sequence() specifying how many instructions will trigger an automatic flush.  You can make this larger for efficiency, or smaller if you want to see the render progress with more frequently.  There is no limit on the size of the queue, except memory used in the Wasm module.  There is a flush() function that you can manually call, but it is not normally needed, unless you would like to ensure a sequence renders before d2d_end_draw_sequence() is called, or before the count passed d2d_start_draw_sequence() is met.</p> <p>If you are using twrWasmModuleAsync, or if you are re-rendering the entire frame for each animation update, you should ensure that all of your draws for a single complete frame are made without a call to flush() in the middle of the draw operations, as this may cause flashing.</p>"},{"location":"api/api-c-d2d/#functions","title":"Functions","text":"<p>These are the Canvas APIs currently available in C:</p> <pre><code>struct d2d_draw_seq* d2d_start_draw_sequence(int flush_at_ins_count);\nvoid d2d_end_draw_sequence(struct d2d_draw_seq* ds);\nvoid d2d_flush(struct d2d_draw_seq* ds);\nint d2d_get_canvas_prop(const char* prop);\n\nvoid d2d_fillrect(struct d2d_draw_seq* ds, double x, double y, double w, double h);\nvoid d2d_strokerect(struct d2d_draw_seq* ds, double x, double y, double w, double h);\nvoid d2d_filltext(struct d2d_draw_seq* ds, const char* str, double x, double y);\nvoid d2d_fillcodepoint(struct d2d_draw_seq* ds, char c, double x, double y);\n\nvoid d2d_measuretext(struct d2d_draw_seq* ds, const char* str, struct d2d_text_metrics *tm);\nvoid d2d_save(struct d2d_draw_seq* ds);\nvoid d2d_restore(struct d2d_draw_seq* ds);\n\nvoid d2d_setlinewidth(struct d2d_draw_seq* ds, double width);\nvoid d2d_setfillstylergba(struct d2d_draw_seq* ds, unsigned long color);\nvoid d2d_setstrokestylergba(struct d2d_draw_seq* ds, unsigned long color);\nvoid d2d_setfillstyle(struct d2d_draw_seq* ds, const char* css_color);\nvoid d2d_setstrokestyle(struct d2d_draw_seq* ds, const char* css_color);\nvoid d2d_setfont(struct d2d_draw_seq* ds, const char* font);\n\nvoid d2d_createlineargradient(struct d2d_draw_seq* ds, long id, double x0, double y0, double x1, double y1);\nvoid d2d_createradialgradient(struct d2d_draw_seq* ds, long id, double x0, double y0, double radius0, double x1, double y1, double radius1);\nvoid d2d_addcolorstop(struct d2d_draw_seq* ds, long gradID, long position, const char* csscolor);\nvoid d2d_setfillstylegradient(struct d2d_draw_seq* ds, long gradID);\nvoid d2d_releaseid(struct d2d_draw_seq* ds, long id);\n\nvoid d2d_beginpath(struct d2d_draw_seq* ds);\nvoid d2d_fill(struct d2d_draw_seq* ds);\nvoid d2d_stroke(struct d2d_draw_seq* ds);\nvoid d2d_moveto(struct d2d_draw_seq* ds, double x, double y);\nvoid d2d_lineto(struct d2d_draw_seq* ds, double x, double y);\nvoid d2d_arc(struct d2d_draw_seq* ds, double x, double y, double radius, double start_angle, double end_angle, bool counterclockwise);\nvoid d2d_bezierto(struct d2d_draw_seq* ds, double cp1x, double cp1y, double cp2x, double cp2y, double x, double y);\n\nvoid d2d_imagedata(struct d2d_draw_seq* ds, long id, void*  mem, unsigned long length, unsigned long width, unsigned long height);\nvoid d2d_putimagedata(struct d2d_draw_seq* ds, long id, unsigned long dx, unsigned long dy);\nvoid d2d_putimagedatadirty(struct d2d_draw_seq* ds, long id, unsigned long dx, unsigned long dy, unsigned long dirtyX, unsigned long dirtyY, unsigned long dirtyWidth, unsigned long dirtyHeight);\n</code></pre> <p>d2d_measuretext() returns this structure:</p> <pre><code>struct d2d_text_metrics {\n    double actualBoundingBoxAscent;\n    double actualBoundingBoxDescent;\n    double actualBoundingBoxLeft;\n    double actualBoundingBoxRight;\n    double fontBoundingBoxAscent;\n    double fontBoundingBoxDescent;\n    double width;\n};\n</code></pre> <p>d2d_get_canvas_prop() returns a value of:</p> <pre><code>export interface ICanvasProps {\n   charWidth: number,\n   charHeight: number,\n   foreColor: number,\n   backColor: number,\n   widthInChars: number,\n   heightInChars: number,\n   canvasWidth:number,\n   canvasHeight:number\n}\n</code></pre>"},{"location":"api/api-c-general/","title":"General C API for Wasm","text":""},{"location":"api/api-c-general/#overview","title":"Overview","text":"<p>This sections describes the \"general\" twr-wasm functions available that don't fit neatly into another category (such as standard C library functions, Draw 2D functions, etc.) </p> <p>These functions often start with \"twr_\" and are generally found in this include file:</p> <p><code>\\twr-wasm\\include\\twr-crt.h</code></p>"},{"location":"api/api-c-general/#bzero","title":"bzero","text":"<p>Set a block of memory to zeros.  Calls <code>memset(to, 0, count)</code>.</p> <pre><code>#include &lt;string.h&gt;\n\nvoid bzero (void *to, size_t count);\n</code></pre>"},{"location":"api/api-c-general/#getc","title":"getc","text":"<p>This is the standard c library function (see the the standard library docs available on the internet). </p> <p>Of note this function will return extended ASCII (128-255 inclusive).  The extend ASCII are always encoded with Windows-1252 encoding.  </p> <p>See <code>twr_getc32</code> for  a list of related functions.</p> <p>Note that C character input is blocking and you must use twrWasmModuleAsync -- see stdin for details on how to enable blocking character input.</p>"},{"location":"api/api-c-general/#twr_atod","title":"twr_atod","text":"<p>Similar to stdlib <code>atof</code>.</p> <pre><code>#include \"twr-crt.h\"\n\ndouble twr_atod(const char* str);\n</code></pre>"},{"location":"api/api-c-general/#twr_atou64","title":"twr_atou64","text":"<p>Convert a string to a 64 bit unsigned integer, stopping when the first non-valid character is encountered.  If len is provided, it will be set to the number of characters read.  Radix should be &gt;=2 and &lt;=36 -- for example, 10 is a normal base 10 number and 16 is hexadecimal.</p> <pre><code>#include \"twr-crt.h\"\n\nint64_t twr_atou64(const char *str, int* len, int radix);\n</code></pre>"},{"location":"api/api-c-general/#twr_dtoa","title":"twr_dtoa","text":"<p>The functions to convert double to text are <code>snprintf</code>, <code>fcvt_s</code>,<code>twr_dtoa</code>, <code>twr_toexponential</code>, and <code>twr_tofixed</code></p> <pre><code>#include \"twr-crt.h\"\n\nvoid twr_dtoa(char* buffer, int sizeInBytes, double value, int max_precision);\n</code></pre>"},{"location":"api/api-c-general/#twr_cache_mallocfree","title":"twr_cache_malloc/free","text":"<p>These functions keep allocated memory in a cache for much faster re-access than the standard malloc/free.</p> <pre><code>#include \"twr-crt.h\"\n\nvoid *twr_cache_malloc(twr_size_t size);\nvoid twr_cache_free(void* mem);\n</code></pre>"},{"location":"api/api-c-general/#twr_code_page_to_utf32_streamed","title":"twr_code_page_to_utf32_streamed","text":"<p>Return a unicode code point (aka utf-32 value) when passed a byte stream that represents an encoded character using the current local's LC_CTYPE code page. A zero is returned if the byte stream has not yet completed a decode.  </p> <p>For example:</p> <pre><code>int cp\n\nsetlocale(LC_ALL, \"\");  // set to default locale, which will be UTF-8 encoding with local language/region\n\n// turn a UTF-8 Euro into a UTF-32 value\ncp==twr_code_page_to_utf32_streamed(0xE2);\nassert (cp==0);\ncp=twr_code_page_to_utf32_streamed(0x82);\nassert (cp==0);\ncp=twr_code_page_to_utf32_streamed(0xAC);\nassert (cp==0x000020AC);   // Euro Code points\n</code></pre> <pre><code>#include &lt;locale.h&gt;\n\nint twr_code_page_to_utf32_streamed(unsigned char byte) \n</code></pre>"},{"location":"api/api-c-general/#twr_conlog","title":"twr_conlog","text":"<p><code>twr_conlog</code> prints debug messages to the browser console from your C code. <pre><code>#include \"twr-crt.h\"\n\nvoid twr_conlog(char* format, ...);\n</code></pre></p> <p>Each call to twr_conlog() will generate a single call to console.log() in JavaScript to ensure that you see debug prints.  This call is identical to printf, except that it adds a newline.</p> <p>The current implementation does not wait for the debug string to output to the console before returning from twr_conlog, when using twrWasmModuleAsync.  In this case, it can take a small bit of time for the string to make its way across the Worker Thread boundary.  This is normally not a problem and results in faster performance.  But if your code crashes soon after the debug print, the print might not appear.  If you think this is an issue, you can call <code>twr_sleep(1)</code> after your twr_conlog call.  This will force a blocking wait for the print to print.</p> <p>Prior to 1.0, this function was called <code>twr_dbg_printf</code>, and operated slightly differently.</p>"},{"location":"api/api-c-general/#twr_epoch_timems","title":"twr_epoch_timems","text":"<p>Returns the number of milliseconds since the start of the epoch. <pre><code>#include \"twr-wasm.h\"\n\nuint64_t twr_epoch_timems();\n</code></pre></p>"},{"location":"api/api-c-general/#twr_getc32","title":"twr_getc32","text":"<p>Gets a 32 bit unicode code point character from stdin. Unlike the standard C library function <code>getchar</code>, <code>twr_getc32</code> does not buffer a line (that is, <code>twr_getc32</code> will return a character before the user presses Enter).</p> <p><code>twr_getc32</code> is implemented as: <pre><code>int twr_getc32() {\n    return io_getc32(twr_get_stdio_con());\n}\n</code></pre></p> <p>Note that stdlib <code>getchar</code> and <code>ungetc</code> are not currently implemented. </p> <p>Note that C character input is blocking and you must use twrWasmModuleAsync -- see stdin for details on how to enable blocking character input.</p> <p>Also see:</p> <ul> <li><code>io_mbgets</code> - get a multibyte string from a console using the current locale character encoding</li> <li><code>twr_mbgets</code> - similar to <code>io_mbgets</code>, except always gets a multibyte locale format string from stdin.</li> <li><code>io_mbgetc</code> - get a multibyte character from an IoConsole (like <code>stdin</code>) using the current locale character encoding</li> <li><code>getc</code> (sames as <code>fgetc</code>) - get a single byte from a FILE * (IoConsole) -- returning ASCII or extended ASCII (window-1252 encoding)</li> <li><code>io_getc32</code> - gets a 32 bit unicode code point from an IoConsole (which currently needs to be stdin)</li> </ul> <pre><code>#include \"twr-crt.h\"\n\nint twr_getc32();\n</code></pre>"},{"location":"api/api-c-general/#twr_get_navlang","title":"twr_get_navlang","text":"<p>Returns the BCP 47 language tag as found in javacript <code>navigator.language</code>.  If len is not null, it will be filled in with the string length of the language tag.</p> <pre><code>#include \"twr-crt.h\"\n\nconst char* twr_get_navlang(int *len);\n</code></pre>"},{"location":"api/api-c-general/#twr_get_current_locale","title":"twr_get_current_locale","text":"<pre><code>extern inline locale_t twr_get_current_locale(void);\n</code></pre> <p><code>twr_get_current_locale</code> will return the locale that has been set by <code>setlocale</code>.  It can be used to pass to a function that takes a locale_t.</p>"},{"location":"api/api-c-general/#twr_localize_numeric_string","title":"twr_localize_numeric_string","text":"<p>Functions like <code>twr_dtoa</code> do not localize the decimal point.  To get a localized decimal point, you can use <code>printf</code>,  or alternately <code>twr_localize_numeric_string</code> to post process a string.   For example:</p> <pre><code>char b[10];\nstrcpy(b, \"1.23\");\ntwr_localize_numeric_string(b, twr_get_current_locale());\n// if locale was set to french, then b is now 1,23\n</code></pre> <pre><code>#include &lt;locale.h&gt;\n\nvoid twr_localize_numeric_string(char* str, locale_t locale);\n</code></pre>"},{"location":"api/api-c-general/#twr_mem_debug_stats","title":"twr_mem_debug_stats","text":"<p>Print memory map and malloc stats to stderr or stdout.</p> <p>(note FILE * is the same as struct IoConsole*)</p> <pre><code>#include &lt;stdio.h&gt;\n\nvoid twr_mem_debug_stats(struct IoConsole* outcon);\n</code></pre>"},{"location":"api/api-c-general/#twr_mbgets","title":"twr_mbgets","text":"<p>Gets a string from stdin. The string will be in the current locale's character encoding -- ASCII for \"C\", and either UTF-8 or windows-1252 for \"\".  See localization.</p> <pre><code>#include \"twr-crt.h\"\n\nchar* twr_mbgets(char* buffer);\n</code></pre> <p>Internally this function uses the stdio IoConsole -- see the IoConsole section for more advanced input/output.</p> <p>This function will encode characters as specified by the LC_CTYPE category of the current locale.  ASCII is used for \"C\", and UTF-8 and Windows-1252 are also supported (see  localization)</p> <p>Note that C character input is blocking and you must use twrWasmModuleAsync -- see stdin for details on how to enable blocking character input.</p>"},{"location":"api/api-c-general/#twr_mbslen_l","title":"twr_mbslen_l","text":"<p>Returns the number of characters in a string using the character encoding of the passed locale (ASCII for \"C\", UTF-8, or windows-1252 for \"\").  You can use <code>twr_get_current_locale</code> to find the current locale. <pre><code>#include &lt;string.h&gt;\n\nsize_t twr_mbslen_l(const char *str, locale_t locale);\n</code></pre></p>"},{"location":"api/api-c-general/#twr_sleep","title":"twr_sleep","text":"<p><code>twr_sleep</code> is a traditional blocking sleep function.   This function is blocking, and you must use twrWasmModuleAsync.</p> <pre><code>#include \"twr-wasm.h\"\n\nvoid twr_sleep(int ms);\n</code></pre>"},{"location":"api/api-c-general/#twr_tofixed","title":"twr_tofixed","text":"<p>This function is identical to its JavaScript version. <pre><code>#include \"twr-wasm.h\"\n\nvoid twr_tofixed(char* buffer, int buffer_size, double value, int dec_digits);\n</code></pre></p> <p>The functions to convert double to text are <code>snprintf</code>, <code>fcvt_s</code>,<code>twr_dtoa</code>, <code>twr_toexponential</code>, and <code>twr_tofixed</code></p>"},{"location":"api/api-c-general/#twr_toexponential","title":"twr_toexponential","text":"<p>This function is identical to its JavaScript version.</p> <pre><code>#include \"twr-wasm.h\"\n\nvoid twr_toexponential(char* buffer, int buffer_size, double value, int dec_digits);\n</code></pre> <p>The functions to convert double to text are <code>snprintf</code>, <code>fcvt_s</code>,<code>twr_dtoa</code>, <code>twr_toexponential</code>, and <code>twr_tofixed</code></p>"},{"location":"api/api-c-general/#twr_strhorizflip","title":"twr_strhorizflip","text":"<p>Mirror image the passed in string. <pre><code>#include \"twr-crt.h\"\n\nvoid twr_strhorizflip(char * buffer, int n);\n</code></pre></p>"},{"location":"api/api-c-general/#twr_utf8_char_len","title":"twr_utf8_char_len","text":"<p>Returns the number of bytes in a UTF-8 character (passed as a string pointer).  UTF-8 characters can be 1 to 4 bytes in length. <pre><code>#include &lt;string.h&gt;\n\nint twr_utf8_char_len(const char *str);\n</code></pre></p>"},{"location":"api/api-c-general/#twr_utf32_to_code_page","title":"twr_utf32_to_code_page","text":"<p>Takes a utf32 value (aka unicode code point value), and fills in the passed character array buffer with the character encoding of the utf32 value, using the current locale's LC_CTYPE code page. The buffer is 0 terminated.</p> <p>Also see <code>c32rtomb</code> and <code>c16rtomb</code>.</p> <p>For example: <pre><code>char strbuf[6];             // max size of utf-8 is 4+terminating zero.  Max size of ASCII or windows 1252 is 1 + terminating zero\nsetlocale(LC_ALL, \"\");  // set to default locale, which will be UTF-8 encoding with local language/region\ntwr_utf32_to_code_page(strbuf, 0x000020AC);  // encode a Euro code point \nprintf(\"%s\", strbuf); \nassert ( strcmp(strbuf,\"\\xE2\\x82\\xAC\")==0 );  // utf-8 encoding of euro\nassert ( strcmp(strbuf,\"\u20ac\")==0 );           // clang string literals default to utf-8 encoding\n</code></pre></p> <pre><code>include &lt;locale.h&gt;\n\nvoid twr_utf32_to_code_page(char* out, int utf32)\n</code></pre>"},{"location":"api/api-c-general/#twr_vprintf","title":"twr_vprintf","text":"<p>Performs a printf by calling the callback with cbdata for each character. <pre><code>#include \"twr-crt.h\"\n\nvoid twr_vprintf(twr_cbprintf_callback out, void* cbdata, const char *format, va_list* args);\n</code></pre></p>"},{"location":"api/api-c-general/#floating-math-helpers","title":"floating math helpers","text":"<pre><code>int twr_isnan(double v);\nint twr_isinf(double v);\ndouble twr_nanval();\ndouble twr_infval();\n</code></pre>"},{"location":"api/api-c-stdlib/","title":"Standard C library for WebAssembly","text":"<p>This section describes twr-wasm's support for the Standard C Library.   twr-wasm includes its own implementation of the standard C library optimized for WebAssembly and Wasm running in a web browser.  This is a core feature of twr-wasm.</p> <p>For documentation of these functions, see the many standard C library documentation web sites.</p> <p>The following subset of the standard C library is available. Also see <code>twr-wasm/include</code> folder for include files.</p>"},{"location":"api/api-c-stdlib/#stdioh","title":"stdio.h","text":"<pre><code>* fprintf will only work with these -- stderr, stdin, stdout */\n/* these return 'struct IoConsole *' which is same as 'FILE *' */\n#define stderr (FILE *)(twr_get_stderr_con())\n#define stdin (FILE *)(twr_get_stdio_con())\n#define stdout (FILE *)(twr_get_stdio_con())\n\nint snprintf(char *buffer, size_t bufsz, const char *format, ... );\nint sprintf( char *buffer, const char *format, ... );\nint vsnprintf(char *buffer, size_t bufsz, const char *format, va_list vlist);\nint vasprintf(char **strp, const char* format, va_list vlist );\nint printf(const char* format, ...);\nint vprintf(const char* format, va_list vlist );\nint puts(const char *str);\nint putchar(int c);\n\ntypedef struct IoConsole FILE; \nint vfprintf(FILE *stream, const char *format, va_list vlist);\nint fprintf(FILE *stream, const char* format, ...);\nsize_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);\nint ferror(FILE *stream);\nint feof(FILE *stream);\nint fflush(FILE *stream);\nint is_terminal(FILE *stream);\nint fputc(int ch, FILE* stream);\nint putc(int ch, FILE* stream);\nint fgetc(FILE *stream );\nint getc(FILE *stream);\n</code></pre>"},{"location":"api/api-c-stdlib/#stdlibh","title":"stdlib.h","text":"<pre><code>void *malloc(size_t size);\nvoid free(void *mem);\nsize_t avail(void);\nvoid *realloc( void *ptr, size_t new_size );\nvoid* calloc( size_t num, size_t size );\nvoid *aligned_alloc( size_t alignment, size_t size );\n\nint rand(void);\nvoid srand(int seed);\n\n#define __min(a,b) (((a) &lt; (b)) ? (a) : (b))\n#define __max(a,b) (((a) &gt; (b)) ? (a) : (b))\n\nint _fcvt_s(\n   char* buffer,\n   size_t sizeInBytes,\n   double value,\n   int fracpart_numdigits,\n   int *dec,\n   int *sign\n);\ndouble atof(const char* str);\nint atoi(const char *str);\nlong atol( const char *str );\nlong long atoll( const char *str );\nlong strtol(const char *str, char **str_end, int base);\nlong long strtoll(const char *str, char **str_end, int base);\nlong long strtoll_l(const char *str, char **str_end, int base,  locale_t loc);\nunsigned long long strtoull(const char *str, char **str_end,  int base);\nunsigned long long strtoull_l(const char *str, char **str_end,  int base, locale_t loc);\nunsigned long strtoul(const char *str, char ** str_end,  int base);\nfloat strtof(const char *str, char ** str_end);\nfloat strtof_l(const char *str, char ** str_end, locale_t locale);\ndouble strtod(const char *str, char **str_end);\ndouble strtod_l(const char *str, char **str_end, locale_t locale);\nlong double strtold(const char *str, char **str_end);\nlong double strtold_l(const char *str, char **str_end, locale_t locale);\nint _itoa_s(int64_t value, char * buffer, size_t size, int radix);\n\ndiv_t div( int x, int y );\nldiv_t ldiv( long x, long y );\nlldiv_t lldiv( long long x, long long y );\n\n_Noreturn void abort(void);\nint atexit(void (*func)(void));\n</code></pre> <p>Note that _fcvt_s as currently enabled has these limitations:    - fractional digits &lt;=100    - values must be less than 1e+21    - values negative exponents must be smaller than 1e-99</p> <p>There is a full featured version of _fcvt_s in the source code, but is not currently enabled, since the version enabled is smaller and works in most use cases.</p>"},{"location":"api/api-c-stdlib/#asserth","title":"assert.h","text":"<pre><code>void assert(int expression);\n</code></pre>"},{"location":"api/api-c-stdlib/#mathh","title":"math.h","text":"<pre><code>int abs(int n);\ndouble acos(double arg);\ndouble asin(double arg);\ndouble atan(double arg);\ndouble ceil(double arg);\ndouble cos(double arg);\ndouble exp(double arg);\ndouble fabs(double arg);\ndouble floor(double arg);\ndouble fmod(double x, double y);\ndouble log(double arg);\ndouble pow(double base, double exp);\ndouble sin(double arg);\ndouble sqrt(double arg);\ndouble tan(double arg);\ndouble trunc(double arg);\n</code></pre>"},{"location":"api/api-c-stdlib/#stdargh","title":"stdarg.h","text":"<pre><code>#define va_start(v,l)   __builtin_va_start(v,l)\n#define va_end(v)   __builtin_va_end(v)\n#define va_arg(v,l) __builtin_va_arg(v,l)\n#define va_copy(d,s)    __builtin_va_copy(d,s)\ntypedef __builtin_va_list va_list;\n</code></pre>"},{"location":"api/api-c-stdlib/#ctypeh","title":"ctype.h","text":"<pre><code>int isascii(int);\nint toascii(int);\nint isalnum(int c);\nint isalpha(int c);\nint isblank(int);\nint iscntrl(int);\nint isdigit(int c);\nint isgraph(int c);\nint islower(int);\nint isprint(int);\nint ispunct(int);\nint isspace(int c);\nint isupper(int);\nint isxdigit(int);\nint tolower(int c);\nint toupper(int c);\n\nint isalnum_l(int c, locale_t loc);\nint isalpha_l(int c, locale_t loc);\nint isblank_l(int c, locale_t loc);\nint iscntrl_l(int c, locale_t loc);\nint isdigit_l(int c, locale_t loc);\nint isgraph_l(int c, locale_t loc);\nint islower_l(int c, locale_t loc);\nint isprint_l(int c, locale_t loc);\nint ispunct_l(int c, locale_t loc);\nint isspace_l(int c, locale_t loc);\nint isupper_l(int c, locale_t loc);\nint isxdigit_l(int c, locale_t loc);\nint tolower_l(int c, locale_t loc);\nint toupper_l(int c, locale_t loc);\n</code></pre>"},{"location":"api/api-c-stdlib/#stddefh","title":"stddef.h","text":"<pre><code>#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)\ntypedef __PTRDIFF_TYPE__ ptrdiff_t;\ntypedef double max_align_t;\n</code></pre>"},{"location":"api/api-c-stdlib/#stringh","title":"string.h","text":"<pre><code>size_t strlen(const char * str);\nchar *strdup(const char * source);\nchar *strcpy(char *dest, const char *source);\nint strcat_s(char *dest, size_t destsz, const char *src);\nchar* strcat(char *dest, const char *src);\nchar *strncpy(char *dest, const char *source, size_t count);\nint strcmp(const char* string1, const char* string2);\nint strncmp(const char* lhs, const char* rhs, size_t count);\nint stricmp(const char* string1, const char* string2);\nint strnicmp(const char* string1, const char* string2, size_t count);\nint strcoll(const char* lhs, const char* rhs);\nint strcoll_l(const char* lhs, const char* rhs,  locale_t loc);\nchar *strchr(const char *str, int ch);\nvoid *memchr(const void *ptr, int ch, size_t count);\nchar *strstr(const char *haystack, const char *needle);\nchar * strerror(int errnum );\nchar * _strerror(const char *strErrMsg);\nvoid *memmove(void *dest, const void *src, size_t n);\nint memcmp( const void* lhs, const void* rhs, size_t count );\nvoid bzero (void *to, size_t count);\n\n// implemented in memcpy.wat\nvoid *memcpy(void *dest, const void * src, size_t n);\nvoid *memset(void *mem, int c, size_t n);\n</code></pre>"},{"location":"api/api-c-stdlib/#timeh","title":"time.h","text":"<pre><code>typedef unsigned long time_t;\nunsigned long time(unsigned long *time);\nsize_t strftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr);\nsize_t strftime_l(char *s, size_t maxsize, const char *format, const struct tm *timeptr, locale_t  locale);\nstruct tm *localtime(const time_t *timer);\nint gettimeofday(struct timeval *tv, void* notused);\n#define timerisset(tvp)     ((tvp)-&gt;tv_sec || (tvp)-&gt;tv_usec)\n#define timercmp(tvp,uvp,cmp)                   \\\n        ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec ||     \\\n         ((tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec &amp;&amp; (tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec))\n#define timerclear(tvp)     (tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0\n</code></pre>"},{"location":"api/api-c-stdlib/#localeh","title":"locale.h","text":"<pre><code>#define LC_GLOBAL_LOCALE twr_get_current_locale()\nchar* setlocale(int category, const char* locale);\nstruct lconv *localeconv(void);\nlocale_t newlocale(int category_mask, const char *locale, locale_t base);\nlocale_t    uselocale(locale_t);\nvoid freelocale(locale_t);\nlocale_t duplocale(locale_t);\nextern inline locale_t twr_get_current_locale(void);\n</code></pre>"},{"location":"api/api-c-stdlib/#ucharh","title":"uchar.h","text":"<pre><code>typedef uint_least32_t char32_t;\ntypedef uint_least16_t char16_t;\n\nsize_t c32rtomb( char* s, char32_t c32, mbstate_t* ps );\n</code></pre>"},{"location":"api/api-c-stdlib/#errnoh","title":"errno.h","text":"<pre><code>typedef int errno_t;\n\nextern int * _errno(void);\n#define errno (*_errno())\n\nerrno_t  _set_errno(int _Value);\nerrno_t  _get_errno(int *_Value);\n</code></pre>"},{"location":"api/api-c-stdlib/#_stdtypesh","title":"_stdtypes.h","text":"<p>// don't include directly -- included by various .h files <pre><code>typedef unsigned long size_t;\n#define MAX_SIZE_T 2147483647  \n\n#ifdef __cplusplus\n#define NULL __null\n#else\n#define NULL ((void*)0)\n#endif\n\ntypedef struct __locale_t_struct * locale_t;\n</code></pre></p>"},{"location":"api/api-c-stdlib/#other-include-files-available","title":"Other include files available","text":"<pre><code>float.h\nlimits.h\nstdbool.h\nstdint.h\n</code></pre>"},{"location":"api/api-libc%2B%2B/","title":"libc++ for WebAssembly","text":"<p>This section describes twr-wasm's support for using the standard c++ library libc++ with WebAssembly.</p> <p>twr-wasm includes libc++ built for WebAssembly in the <code>twr-wasm/lib-c</code> folder.</p> <p>For C++ the use of libc++ is optional.  That is you can build twr-wasm projects in C++ with or without libc++.</p> <p>See the examples tests-libcx and tests-user for examples of using libc++.</p> <p>See the balls example for how to create a C++ WebAssembly program without the standard C++ library.  The primary advantage to this approach is a bit smaller code size.  You don't need to staticly link libc++.</p> <p>Some of the key options twr-wasm's libc++ for WebAssembly was built with are these:</p> <pre><code>DLIBCXX_ENABLE_LOCALIZATION=ON \nDLIBCXX_ENABLE_UNICODE=ON \nDLIBCXX_ENABLE_RTTI=ON \nDLIBCXX_ENABLE_STATIC_ABI_LIBRARY=ON \n\nDCMAKE_BUILD_TYPE=Release       \nDCMAKE_CXX_STANDARD=20 \n\nDLIBCXX_ENABLE_EXCEPTIONS=OFF \nDLIBCXX_ENABLE_THREADS=OFF \nDLIBCXX_ENABLE_SHARED=OFF \nDLIBCXX_ENABLE_WIDE_CHARACTERS=OFF \nDLIBCXX_ENABLE_FILESYSTEM=OFF \nDLIBCXX_ENABLE_TIME_ZONE_DATABASE=OFF \nDLIBCXX_ENABLE_MONOTONIC_CLOCK=OFF \nDLIBCXX_ENABLE_RANDOM_DEVICE=OFF\n</code></pre>"},{"location":"api/api-localization/","title":"Localization Reference for twr-wasm","text":"<p>This section details twr-wasm's WebAssembly localization support.</p> <p>Also see Introduction to Character Encoding Support with twr-wasm</p>"},{"location":"api/api-localization/#using-c","title":"Using C:","text":"<p>Standard C locale functions are supported by twr-wasm.  ASCII, UTF-8 and windows-1252 encoding is supported by the twr-wasm standard C library locale.  twr-wasm also includes C functions for UTF-32 support.</p>"},{"location":"api/api-localization/#using-c_1","title":"Using C++:","text":"<ul> <li>libc++ locale and unicode functions are supported by twr-wasm.</li> <li>libc++ unicode support includes utf-16 and utf-32 strings.</li> </ul>"},{"location":"api/api-localization/#character-encodings","title":"Character Encodings","text":"<p>twr-wasm C locales support ASCII, UTF-8 or windows-1252 encoding.  UTF-16/32 are not supported as a std c lib locale setting, but functions are provided to convert utf-32 (unicode code points) to and from ASCII, UTF-8, and windows-1252 \"code pages\" (there are other miscellaneous utf-32 based functions as well.)</p>"},{"location":"api/api-localization/#locales-standard-c-library","title":"Locales (Standard C Library)","text":""},{"location":"api/api-localization/#c","title":"\"C\"","text":"<p>\"C\" is the default locale, as usual.  When \"C\" is selected, the functions operate as usual. One subtly is that console i/o functions (such as <code>printf</code>) will generally function as expected with UTF-8, since the <code>div</code> and <code>window</code> consoles correctly handle UTF-8 character encoding.  This is normal on some OSs, such as linux, but not the default on Windows (which often defaults to windows-1252 for backward compatibility).</p> <p><code>isgraph</code> style functions will only recognize ASCII characters, as is normal.   Functions such as <code>strcmp</code> operate on the byte sequence, which will typically results in UTF-8 codes being compared lexically. <code>strcoll</code> will use lexical ordering.</p>"},{"location":"api/api-localization/#posix","title":"\"POSIX\"","text":"<p>\"POSIX\" is the same as \"C\"</p>"},{"location":"api/api-localization/#_1","title":"\"\"","text":"<p>\"\" is the locale to specify the users default setting (this selects the setting used by the browser).  This will also enable UTF-8 in functions such as <code>strcoll</code>.  For example, if your browser is set to \"en-US\" as its default locale, <code>setlocale(LC_ALL, \"\")</code> will return <code>en-US.UTF-8</code>.  </p> <p><code>isgraph</code> style functions will still only recognize ASCII characters (since UTF-8 doesn't encode any single bytes greater than 127).  <code>strcoll</code>  uses locale specific ordering, and <code>printf</code> will use locale specific decimal points.  <code>strcmp</code> still compares two strings lexicographically (byte-by-byte) without considering locale-specific rules, per the spec. </p>"},{"location":"api/api-localization/#utf-8","title":"\".UTF-8\"","text":"<p>\".UTF-8\" is the same as \"\" with twr-wasm.</p>"},{"location":"api/api-localization/#1252","title":"\".1252\"","text":"<p>\".1252\" will select the current default locale, but use windows-1252 character encoding (instead of UTF-8). Windows-1252 is a super set of ISO-8859-1 and is the most commonly used encoding for many european languages when unicode is not used.  This mode is primarily for legacy software, backwards compatibly, and windows compatibility.   </p>"},{"location":"api/api-localization/#others","title":"Others","text":"<p>Setting arbitrary locales, such as \"fr-FR\" when the browser is defaulted to another locale, is not supported.  </p>"},{"location":"api/api-localization/#select-the-default-locale","title":"Select the default locale","text":"<p>To select the user's browser's default locale using the C language, and enable consistent utf-8 support, use a call like this:</p> <pre><code>setlocale(LC_ALL, \"\")\n</code></pre>"},{"location":"api/api-localization/#c-and-libc-functions","title":"C and libc++ functions","text":"<p>If you are using twr-wasm's build of libc++, libc++ locale and unicode functions work as normal.</p> <p>The usual standard C library locale support is available, along with some POSIX extensions.   In addition, some locale useful twr-wasm specific functions are documented in C API, such as <code>twr_get_current_locale</code>,<code>twr_mbgets</code>, <code>twr_getc32</code>, <code>twr_utf8_char_len</code>, <code>twr_mbslen_l</code>, <code>twr_utf32_to_code_page</code>, <code>twr_code_page_to_utf32_streamed</code>, <code>twr_get_navlang</code>, <code>twr_localize_numeric_string</code>.</p> <p>Note that <code>io_getc32</code>, <code>getc(stdin)</code>, <code>fgetc(stdin)</code> do not look at the current locale.  <code>io_getc32</code> returns a 32 bit unicode code point, and <code>getc</code>/<code>fgetc</code> return extended ASCII. </p> <p>For a locale aware character input, use <code>io_mbgetc()</code> or <code>twr_mbgets()</code>. Both use the locale category LC_CTYPE.  See C API.</p> <p>Note that when the locale is not set (or whenever the \"C\" locale is set) functions that get character(s) from stdin that are locale aware, like <code>twr_mbgets()</code>, behave different than functions that output characters to stdout (like  <code>puts</code>, <code>io_putstr</code>, <code>io_putc</code>, <code>putchar</code>).  Characters to stdout in \"C\" locale will handle UTF-8 characters.  For stdin, \"C\" locale uses ASCII.</p> <p>For consistent UTF-8 (or windows-1252) behavior, set the locale as discussed above ( use <code>setlocale</code> )</p> <p>The primary standard C library locale functions are: <pre><code>char* setlocale(int category, const char* locale);\nstruct lconv *localeconv(void);\n</code></pre></p> <p>As well as the two standard library functions above, appropriate functions take into account the current locale (printf, strcoll, etc).</p> <p>Note that <code>setlocale</code> returns a string using BCP 47 format (like a web browser).  Locale strings look like \"en-US.UTF-8\", instead of \"en_US.UTF-8\". A dash, not an underscore, is used as a separator.</p> <p>POSIX functions These are the extended POSIX style functions provided that are related to locale:</p> <pre><code>locale_t newlocale(int category_mask, const char *locale, locale_t base);\nlocale_t uselocale(locale_t);\nvoid freelocale(locale_t);\nlocale_t duplocale(locale_t);\n\nint isalnum_l(int c, locale_t loc);\nint isalpha_l(int c, locale_t loc);\nint isblank_l(int c, locale_t loc);\nint iscntrl_l(int c, locale_t loc);\nint isdigit_l(int c, locale_t loc);\nint isgraph_l(int c, locale_t loc);\nint islower_l(int c, locale_t loc);\nint isprint_l(int c, locale_t loc);\nint ispunct_l(int c, locale_t loc);\nint isspace_l(int c, locale_t loc);\nint isupper_l(int c, locale_t loc);\nint isxdigit_l(int c, locale_t loc);\nint tolower_l(int c, locale_t loc);\nint toupper_l(int c, locale_t loc);\n\nlong long strtoll_l(const char *str, char **str_end, int base,  locale_t loc);\nunsigned long long strtoull_l(const char *str, char **str_end,  int base, locale_t loc);\nfloat strtof_l(const char *str, char ** str_end, locale_t locale);\ndouble strtod_l(const char *str, char **str_end, locale_t locale);\nlong double strtold_l(const char *str, char **str_end, locale_t locale);\n\nint strcoll_l(const char* lhs, const char* rhs,  locale_t loc);\n\nsize_t strftime_l(char *s, size_t maxsize, const char *format, const struct tm *timeptr, locale_t locale);\n</code></pre>"},{"location":"api/api-typescript/","title":"TypeScript-JavaScript API to load and call Wasm","text":"<p>This section describes the twr-wasm TypeScript/JavaScript classes that you use to load your Wasm modules, and to call C functions in your Wasm modules.</p> <p><code>class twrWasmModule</code> and <code>class twrWasmModuleAsync</code> have similar APIs.  The primary difference is that <code>class twrWasmModuleAsync</code> proxies functionality through a Web Worker thread, which allows blocking C functions to be called in your WebAssembly Module.</p>"},{"location":"api/api-typescript/#class-twrwasmmodule","title":"class twrWasmModule","text":"<p><pre><code>import {twrWasmModule} from \"twr-wasm\";\n\nconst mod = new twrWasmModule();\n</code></pre> <code>twrWasmModule</code> provides the two core JavaScript APIs for access to a WebAssembly Module: </p> <ul> <li><code>loadWasm</code> to load your <code>.wasm</code> module (your compiled C code).</li> <li><code>callC</code> to call a C function</li> </ul> <p>These functions are documented further down in this section.</p>"},{"location":"api/api-typescript/#class-twrwasmmoduleasync","title":"class twrWasmModuleAsync","text":"<pre><code>import {twrWasmModuleAsync} from \"twr-wasm\";\n\nconst amod = new twrWasmModuleAsync();\n</code></pre> <p><code>twrWasmModuleAsync</code> implements all of the same functions as <code>twrWasmModule</code>, plus allows blocking inputs, and blocking code generally. This is achieved by proxying all the calls through a Web Worker thread. </p> <p>Use <code>twrWasmModuleAsync</code> if your C code blocks, or if you are unsure.  If you want better performance and don't need the capabilities of <code>twrWasmModuleAsync</code>, use <code>twrWasmModule</code>.</p> <p>You must use <code>twrWasmModuleAsync</code> in order to:</p> <ul> <li>call any blocking C function (meaning it takes \"a long time\") to return</li> <li>use blocking input from a div or canvas ( eg. <code>twr_mbgets</code> )</li> <li>use <code>twr_sleep</code></li> </ul> <p>See stdio section for information on enabling blocking character input, as well as this Example.</p> <p>When linking your C/C++ code, <code>twrWasmModule</code> and <code>twrWasmModuleAsync</code> use slightly different <code>wasm-ld</code> options since <code>twrWasmModuleAsync</code> uses shared memory. <code>twrWasmModule</code> will operate with shared memory, so technically you could just use the same share memory options with either module,  but you don't need the overhead of shared memory when using twrWasmModule, and so better to not enable it.</p> <p>See Compiler Options.</p> <p><code>twrWasmModuleAsync</code> uses SharedArrayBuffers which require certain HTTP headers to be set. Note that <code>twrWasmModule</code> has an advantage in that it does not use SharedArrayBuffers.</p> <p>Github pages doesn't support the needed CORS headers for SharedArrayBuffers.  But other web serving sites do have options to enable the needed CORS headers.  For example, the azure static web site config file <code>staticwebapp.config.json</code> looks like this: <pre><code>{\n    \"globalHeaders\": {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Cross-Origin-Embedder-Policy\": \"require-corp\",\n      \"Cross-Origin-Opener-Policy\": \"same-origin\"\n    }\n}\n</code></pre></p> <p>server.py in the examples folder will launch a local server with the correct headers.  To use Chrome without a web server, see the Hello World walk through.</p>"},{"location":"api/api-typescript/#class-options","title":"Class Options","text":"<p>The <code>twrWasmModule</code> and <code>twrWasmModuleAsync</code> constructor both take optional options.</p> <p>For example: <pre><code>let amod=new twrWasmModuleAsync();\n\nlet amod=new twrWasmModuleAsync({\n   windim:[50,20], \n   forecolor:\"beige\", \n   backcolor:\"DarkOliveGreen\", \n   fontsize:18\n   });\n</code></pre></p> <p>For a <code>&lt;div id=\"twr_iodiv\"&gt;</code> it is simpler to set the color and font in the div tag per the normal HTML method.  But for <code>&lt;div id=\"twr_iocanvas\"&gt;</code>, that method won't work and you need to use the constructor options for color and fontsize.</p> <p>These are the options: <pre><code>export type TStdioVals=\"div\"|\"canvas\"|\"null\"|\"debug\";\n\nexport interface IModOpts {\n   stdio?:TStdioVals, \n   windim?:[number, number],\n   forecolor?:string,\n   backcolor?:string,\n   fontsize?:number,\n   imports?:{},\n}\n</code></pre></p>"},{"location":"api/api-typescript/#stdio","title":"stdio","text":"<p>You can explicitly set your stdio source (for C/C++ printf, etc) with the stdio option, but typically you don't set it.  Instead, it will auto set as described here</p>"},{"location":"api/api-typescript/#windim","title":"windim","text":"<p>This options is used with a terminal console ( <code>&lt;canvas id=\"twr_iocanvas\"&gt;</code> ) to set the width and height, in characters.</p> <p>The canvas width and height, in pixels, will be set based on your fontsize and the width and height (in characters) of the terminal.</p>"},{"location":"api/api-typescript/#forecolor-and-backcolor","title":"forecolor and backcolor","text":"<p>These can be set to a CSS color (like '#FFFFFF' or 'white') to change the default background and foreground colors.</p>"},{"location":"api/api-typescript/#fonsize","title":"fonsize","text":"<p>Changes the default fontsize for div or canvas based I/O. The size is in pixels.</p>"},{"location":"api/api-typescript/#loadwasm","title":"loadWasm","text":"<p>Use <code>loadWasm</code> to load your compiled C/C++ code (the <code>.wasm</code> file).  <pre><code>await mod.loadWasm(\"./mycode.wasm\")\n</code></pre></p>"},{"location":"api/api-typescript/#callc","title":"callC","text":"<p>After your .<code>wasm</code> module is loaded with <code>loadWasm</code>, you call functions in your C/C++ from TypeScript/JavaScript like this: <pre><code>let result=await amod.callC([\"bounce_balls_move\", param1])\n</code></pre></p> <p>If you are calling into C++, you need to use extern \"C\" like this in your C++ code: <pre><code>extern \"C\" int bounce_balls_move() {}\n</code></pre></p> <p>Each C/C++ function that you wish to call from TypeScript/JavaScript needs to be exported in your wasm-ld settings like this: <pre><code>--export=bounce_balls_move\n</code></pre> Or like this in your source file: <pre><code>__attribute__((export_name(\"bounce_balls_move\")))\nvoid bounce_balls_move() {\n   ...\n</code></pre></p> <p>See the Compiler Options.</p> <p><code>callC</code> takes an array where:</p> <ul> <li>the first entry is the name of the C function in the Wasm module to call </li> <li> <p>and the next entries are a variable number of parameters to pass to the C function, of type:</p> <ul> <li><code>number</code> - will be converted to int32 or float64 as appropriate</li> <li><code>string</code> - converted to a pointer to module Memory where string is copied into</li> <li><code>ArrayBuffer</code> - the array is loaded into module memory.  If you need to pass the length, pass it as a separate parameter.  Any modifications to the memory made by your C code will be reflected back into the JavaScript ArrayBuffer.</li> <li><code>URL</code> - the url contents are loaded into module Memory, and two C parameters are generated - index (pointer) to the memory, and length</li> </ul> </li> </ul> <p><code>callC</code> returns the value returned by the C function that was called.  As well <code>int</code> and <code>float</code>, <code>string</code> and structs (or blocks of memory) can be returned. More details can be found in <code>examples/callc</code>.</p> <p>The FFT example demonstrates passing a Float32Array view of an ArrayBuffer.</p> <p>Also see Passing Function Parameters from JavaScript to C/C++ with WebAssembly.</p>"},{"location":"api/api-typescript/#divlog","title":"divLog","text":"<p>If <code>stdio</code> is set to <code>twr_iodiv</code>, you can use the <code>divLog</code> twrWasmModule/Async function like this: <pre><code>import {twrWasmModule} from \"twr-wasm\";\n\nconst mod = new twrWasmModule();\nawait mod.loadWasm(\"./tests.wasm\");\nawait mod.callC([\"tests\"]);\n\nmod.divLog(\"\\nsin() speed test\");\nlet sumA=0;\nconst start=Date.now();\n\nfor (let i=0; i&lt;2000000;i++)\n   sumA=sumA+Math.sin(i);\n\nconst endA=Date.now();\n\nlet sumB=await mod.callC([\"sin_test\"]);\nconst endB=Date.now();\n\nmod.divLog(\"sum A: \", sumA, \" in ms: \", endA-start);\nmod.divLog(\"sum B: \", sumB,  \" in ms: \", endB-endA);\n</code></pre></p>"},{"location":"api/api-typescript/#accessing-data-in-the-webassembly-memory","title":"Accessing Data in the WebAssembly Memory","text":"<p><code>callC()</code> will convert your JavaScript parameters into a form suitable for use by your C code.  However, if you return or want to access struct values inside TypeScript you will find the following functions handy. See the callc example and Passing Function Parameters from JavaScript to C/C++ with WebAssembly for an explanation of how these functions work. <pre><code>async putString(sin:string, codePage=codePageUTF8)  // returns index into WebAssembly.Memory\nasync putU8(u8a:Uint8Array)   // returns index into WebAssembly.Memory\nasync putArrayBuffer(ab:ArrayBuffer)  // returns index into WebAssembly.Memory\nasync fetchAndPutURL(fnin:URL)  // returns index into WebAssembly.Memory\nasync malloc(size:number)           // returns index in WebAssembly.Memory.  \n\nstringToU8(sin:string, codePage=codePageUTF8)\ncopyString(buffer:number, buffer_size:number, sin:string, codePage=codePageUTF8):void\ngetLong(idx:number): number\nsetLong(idx:number, value:number)\ngetDouble(idx:number): number\nsetDouble(idx:number, value:number)\ngetShort(idx:number): number\ngetString(strIndex:number, len?:number, codePage=codePageUTF8): string\ngetU8Arr(idx:number): Uint8Array\ngetU32Arr(idx:number): Uint32Array\n\nmemory?:WebAssembly.Memory;\nmem8:Uint8Array;\nmem32:Uint32Array;\nmemD:Float64Array;\n</code></pre></p>"},{"location":"examples/examples-balls/","title":"Bouncing Balls - 2D Draw API Wasm Example","text":"<p>This example uses twr-wasm's 2D Draw API and a C++ Canvas class with WebAssembly and C++ to bounce balls around your HTML page.</p> <ul> <li>View bouncing balls </li> <li>Source for balls </li> </ul> <p>The bouncing balls example demonstrates</p> <ul> <li>C++</li> <li>Using the twr-wasm draw 2D APIs that match Javascript Canvas APIs.</li> <li>A C++ wrapper for the JavaScript Canvas class</li> </ul> <p>This example does not use libc++, which results in smaller code size.   For an example that uses libc++ see tests-libcxx.</p>"},{"location":"examples/examples-balls/#screen-grab-of-balls-example","title":"Screen Grab of Balls Example","text":""},{"location":"examples/examples-callc/","title":"callC - Calling WebAssembly Functions Example","text":"<p>This example demonstrates how to pass and return values between TypeScript/JavaScript and C/C++ when you are using WebAssembly with twr-wasm.</p> <p>This article explains the key concepts to pass parameters between JavaScript/TypeScript and Wasm C/C++.</p> <ul> <li>View callC example running live</li> <li>View callC example source</li> </ul>"},{"location":"examples/examples-fft/","title":"FFT - Example of using C FFT with HTML/JavaScript","text":"<p>This example is a demo of integrating the popular KISS FFT C library with TypeScript/JavaScript/HTML using WebAssembly.  The FFT C library is compiled into a Wasm (WebAssembly) module using clang, with the help of twr-wasm.   The FFT Wasm module is used by the HTML page to calculate the FFT.  The FFT input and output is drawn to the web page using JavaScript canvas functions.  </p> <p>The FFT library exposes APIs to process data, and doesn't use stdio.</p> <p>The FFT APIs use float32 arrays for complex-number input and output data, and a configuration C struct.   In the example I generate the input data by adding a 1K and 5K sine waves, call the kiss FFT API to perform the FFT on the generated sine waves, and then graph the input and output data using a JavaScript Canvas.</p> <ul> <li>View example running on the web</li> <li>View example source code</li> </ul>"},{"location":"examples/examples-fft/#screen-grab-of-output","title":"Screen Grab of Output","text":""},{"location":"examples/examples-fft/#code","title":"Code","text":"<p>Here is part of the code. The rest can be found on github.</p> <p>index.html<pre><code>&lt;head&gt;\n    &lt;title&gt;Fast Fourier transform (FFT)&lt;/title&gt;\n&lt;/head&gt;\n&lt;body style=\"background-color:white\"&gt;\n\n    &lt;br&gt;\n\n    &lt;div style=\"font:24px arial\"&gt;Input Signal&lt;/div&gt;\n    &lt;canvas id=\"c-input\" width=\"1024\" height=\"300\" style=\"background-color:lightgray\"&gt;&lt;/canvas&gt;\n\n    &lt;br&gt;&lt;br&gt;&lt;br&gt;\n\n    &lt;div style=\"font:24px arial\"&gt;FFT Output&lt;/div&gt;\n    &lt;canvas id=\"c-output\" width=\"1024\" height=\"300\" style=\"background-color:lightgray\"&gt;&lt;/canvas&gt;\n\n    &lt;script type=\"module\"&gt;\n        import {fftDemo} from \"./fft-script.js\";\n\n        fftDemo();\n\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre> fft-script.js<pre><code>import {twrWasmModule} from \"twr-wasm\";\n\nexport async function fftDemo() {\n\n    const mod=new twrWasmModule();\n\n    // load the kiss_fft C code as is, unmodified\n    await mod.loadWasm('kiss_fft.wasm');\n\n    //  kissFFTData stores and graphs the input and output data\n    //  in this example the fft has 1024 bins, and I am using a 48K sampling rate\n    let fft=new kissFFTData(1024, 48000);\n    fft.genSin(1000)\n    fft.addSin(5000)\n    fft.graphIn(\"c-input\");\n\n    // see kiss_fft README, but in summary you: (a) alloc config, (b) compute the FFT, (c) free the config\n    // kiss_fft_alloc() returns a malloced structure.  Pointers are numbers (index into Wasm module memory) in JS land \n    //\n    //kiss_fft_cfg cfg = kiss_fft_alloc( nfft ,is_inverse_fft ,0,0 );\n    let cfg:number = await mod.callC([\"kiss_fft_alloc\", fft.nfft, 0, 0, 0 ]);\n\n    // The FFT input and output data are C arrays of complex numbers.\n    // typedef struct {\n    //    kiss_fft_scalar r;\n    //    kiss_fft_scalar i;\n    // } kiss_fft_cpx;\n    //\n    // /*  default is float */\n    // define kiss_fft_scalar float\n\n    // So if the FFT data has 1024 bins, then 1024 * 2 floats (r &amp; i) * 4 bytes per float are needed.\n    // I use a JS Float32Array view on the ArrayBuffer to access the floats\n\n    // When an arrayBuffer is passed in as an argument to mod.callC,\n    // callC will malloc memory in the Wasm module of a size that matches the array buffer, then\n    // copy the arraybuffer into the malloc'd memory prior to the function call, \n    // then copy the malloc'd memory contents back into the arrayBuffer post call.\n    // The malloc'd memory is free'd post call. \n\n    // void kiss_fft(kiss_fft_cfg cfg,const kiss_fft_cpx *fin,kiss_fft_cpx *fout);\n    await mod.callC([\"kiss_fft\", cfg, fft.inArrayBuf, fft.outArrayBuf]);\n\n    fft.graphOut(\"c-output\");\n\n    await mod.callC([\"free\", cfg]);      // not much point to this since all the module memory is about to disappear\n}\n</code></pre></p>"},{"location":"examples/examples-helloworld/","title":"Hello World - WebAssembly C Example","text":"<p>This example is an very simple twr-wasm program.  It uses WebAssembly and C to print \"hello, world!\" to an HTML <code>&lt;div&gt;</code> tag.</p> <p>Also see: Hello World - Step-by-Step C to Wasm.</p> <ul> <li>View helloworld example running live</li> <li>View helloworld source code</li> </ul>"},{"location":"examples/examples-libcxx/","title":"tests-libcxx - WebAssembly libc++ Smoke Test","text":"<p>This is a simple test of various libc++ functions using WebAssembly with twr-wasm.  The C++ program links with libc++. An example makefile is provided.</p> <ul> <li>view tests-libcxx example running live</li> <li>View tests-libcxx source code</li> </ul> <p>Also see this WebAssembly program that uses libc++ with twr-wasm to implement a CLI console.</p> <ul> <li>tests-user Live</li> <li>tests-user Source</li> </ul>"},{"location":"examples/examples-maze/","title":"Maze Generator/Solver","text":"<p>This example is a port to Wasm of a 20 year old Win32 C Maze creator,  with the help of twr-wasm 2D Draw APIs.</p> <ul> <li>View live maze here</li> <li>Source for maze</li> </ul>"},{"location":"examples/examples-maze/#screen-grab-of-output","title":"Screen Grab of Output","text":""},{"location":"examples/examples-maze/#overview","title":"Overview","text":"<p>This Maze generator uses the twr-wasm \"d2d\" (Draw 2D) C APIs.  These allow drawing onto an HTML canvas from C/C++.  (Also see the balls C++ example).</p> <p>This C code is interesting in that it is a combination of blocking and non blocking functions.  The <code>CalcMaze</code> function is blocking when the \"slow draw\" flag is set.  It uses <code>Sleep</code> in this case.   For this reason, I use twrWasmModuleAsync.   The solve section uses repeated calls to <code>SolveStep</code>, which works well with a JavaScript main loop.  I used a javascript interval timer to make repeated calls to the C <code>SolveStep</code> function.  If all the C code was structured this way, <code>twrWasmModule</code> could have been used (instead of the Async version)</p> <p>To port this code to twr-wasm I wrote a (very tiny) Win32 compatible API (in winemu.c/winemu.h).  It only implements the features needed to port Maze, but it might be useful to use as a starting point for porting your Win32 code to the web.  </p> index.html<pre><code>&lt;head&gt;\n    &lt;title&gt;Maze&lt;/title&gt;\n&lt;/head&gt;\n&lt;body style=\"background-color:powderblue\"&gt;\n    &lt;canvas id=\"twr_d2dcanvas\" width=\"600\" height=\"600\"&gt;&lt;/canvas&gt;\n\n    &lt;script type=\"module\"&gt;\n        import {mazeRunner} from \"./maze-script.js\";\n\n        mazeRunner();\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre> maze-script.js<pre><code>import {twrWasmModuleAsync} from \"twr-wasm\";\n\nexport async function mazeRunner() {\n\n    const amod=new twrWasmModuleAsync();\n\n    await amod.loadWasm('maze.wasm');\n\n    //void CalcMaze(HWND hWnd, LONG cell_size, LONG is_black_bg, LONG isd - slow draw)\n    await amod.callC([\"CalcMaze\", 0, 7, 0, 1]);\n    await amod.callC([\"SolveBegin\"]);\n\n    let timer = setInterval(async ()=&gt;{\n        let isdone=await amod.callC([\"SolveStep\", 0]);  //SolveStep(hwnd))\n        if (isdone) clearInterval(timer);\n    }, 50);\n}\n</code></pre>"},{"location":"examples/examples-overview/","title":"WebAssembly C/C++ Examples","text":""},{"location":"examples/examples-overview/#overview","title":"Overview","text":"<p>These C and C++ examples demonstrate how to create different types of WebAssembly (wasm) programs with the twr-wasm library.</p> <p>These are good examples to use as starting points for your own Wasm projects.</p> <p>These examples are a good place to learn how to configure clang and wasm-ld to compile and link C/C++ code for use with WebAssembly (wasm).</p>"},{"location":"examples/examples-overview/#example-quick-links","title":"Example Quick Links","text":"<ul> <li>Click here to view C/C++ WebAssembly twr-wasm examples running live</li> <li>Click here to view source code and make files</li> </ul>"},{"location":"examples/examples-overview/#examples-overview","title":"Examples Overview","text":"<p>Each of these examples are designed to illustrate how to use a feature of twr-wasm.</p> Name Description Link helloworld A very simple C Wasm example to get you started helloworld stdio-div This simple C program demos inputting andprinting characters to a <code>div</code> tag stdio-div stdio-canvas This simple C program demos writing and inputtingfrom a <code>&lt;canvas&gt;</code> tag that twr-wasm configuresas a windowed \"mini-terminal\" stdio-canvas balls These fun Bouncing Balls are written in C++ and demo the2D drawing APIs with a C++ Canvas wrapper class balls maze This is an old Win32 program ported to wasmand demos the 2D Draw APIs maze fft A demo of calling a C library to perform an FFTthat is graphed in TypeScript fft callC A demo of passing and returning values betweenJavaScript and Wasm module callc tests twr-wasm unit tests tests tests-user \"cli\" for tests using libc++ and <code>&lt;canvas&gt;</code> tests-user tests-libcxx Smoke test for libc++.  Shows how to use libc++. tests-libcxx"},{"location":"examples/examples-overview/#building-the-examples","title":"Building the Examples","text":"<p>See Example Readme for more information on building and running the examples. </p>"},{"location":"examples/examples-stdio-canvas/","title":"stdio-canvas - Terminal Using a Canvas Tag","text":"<p>A simple ANSI WebAssembly C \"terminal\" is created with input and output directed to an HTML <code>&lt;canvas&gt;</code> tag.</p> <p>This example will move a string up or down in the terminal window when you press the u or d or arrow keys. </p> <p>This example also draws a graphic box around the terminal window.</p> <ul> <li>View stdio-canvas example running live</li> <li>View stdio-canvas source code</li> <li>For another 'terminal' demo View tests-user</li> </ul>"},{"location":"examples/examples-stdio-canvas/#screen-grab-of-terminal","title":"Screen Grab of Terminal","text":""},{"location":"examples/examples-stdio-canvas/#c-code","title":"C Code","text":"stdio-canvas.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;locale.h&gt;\n#include \"twr-crt.h\"\n\n/* this twr-wasm C example draws a utf-8 string in the middle of a windowed console, */\n/* and allows the user to move the string up or down with the u, d or arrow keys */\n\n/* see include/twr-io.h for available functions to draw chars to windowed console */\n\nvoid draw_outline(struct IoConsoleWindow* iow);\nvoid show_str_centered(struct IoConsoleWindow* iow, int h, const char* str);\n\nvoid stdio_canvas() {\n    struct IoConsoleWindow* iow=(struct IoConsoleWindow*)twr_get_stdio_con();\n\n    assert(iow-&gt;con.header.type&amp;IO_TYPE_WINDOW);\n\n    setlocale(LC_ALL, \"\");  // set user default locale, which is always UTF-8.  This is here to turn on UTF-8.\n\n    int h;\n    const char* str=\"Hello World (press u, d, \u2191, or \u2193)\";  // arrows are UTF-8 multibyte\n    const char* spc=\"                                 \";\n    char inbuf[6];  // UTF-8 should be max 4 bytes plus string ending 0\n\n    h=iow-&gt;display.height/2;\n\n   draw_outline(iow);\n\n    while (1) {\n      show_str_centered(iow, h,  str);\n      io_mbgetc(stdin, inbuf); // also see twr_getc32 documentation\n      show_str_centered(iow, h,  spc);   // erase old string\n\n      if (strcmp(inbuf,\"u\")==0 || strcmp(inbuf,\"\u2191\")==0) {   // arrows are multibyte UTF-8.\n         h=h-1;\n         if (h&lt;1) h=1;  // border I drew is in the 0 position\n      }\n      if (strcmp(inbuf,\"d\")==0 || strcmp(inbuf,\"\u2193\")==0) {\n         h=h+1;\n         if (h&gt;=(iow-&gt;display.height-1)) h=iow-&gt;display.height-2;  // border I drew is in the height-1 position\n      }\n   }\n}\n\nvoid show_str_centered(struct IoConsoleWindow* iow, int h, const char* str) {\n    int len=twr_mbslen_l(str, twr_get_current_locale());\n    int x=(iow-&gt;display.width-len)/2;\n    io_set_cursorxy(iow, x, h);\n    io_putstr(&amp;iow-&gt;con, str);\n}\n\nvoid draw_outline(struct IoConsoleWindow* iow) {\n   const int w=iow-&gt;display.width*2;   // graphic cells are 2x3\n   const int h=iow-&gt;display.height*3;\n   unsigned long fgcolor, bgcolor;\n\n   io_begin_draw(&amp;iow-&gt;con);\n\n   io_get_colors(&amp;iow-&gt;con, &amp;fgcolor, &amp;bgcolor);\n   io_set_colors(&amp;iow-&gt;con, 0x000000, bgcolor);  // draw in black\n\n   for (int i=0; i&lt;w; i++) {\n      io_setreset(iow, i, 0, true);\n      io_setreset(iow, i, h-1, true);\n   }\n\n   for (int i=0; i&lt;h; i++) {\n      io_setreset(iow, 0, i, true);\n      io_setreset(iow, w-1, i, true);\n   }\n\n   io_set_colors(&amp;iow-&gt;con, fgcolor, bgcolor);  // restore\n\n   io_end_draw(&amp;iow-&gt;con);\n\n}\n</code></pre>"},{"location":"examples/examples-stdio-canvas/#html-code","title":"HTML Code","text":"index.html<pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n   &lt;title&gt;stdio-canvas example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n   &lt;canvas id=\"twr_iocanvas\" tabindex=\"0\"&gt;&lt;/canvas&gt;\n\n   &lt;!-- importmap used when un-bundled --&gt;\n   &lt;script type=\"importmap\"&gt;\n      {\n         \"imports\": {\n         \"twr-wasm\": \"../../lib-js/index.js\"\n         }\n      }\n   &lt;/script&gt;\n\n   &lt;script type=\"module\"&gt;\n      import {twrWasmModuleAsync} from \"twr-wasm\";\n\n      try {\n         const amod = new twrWasmModuleAsync({windim:[50,20], forecolor:\"beige\", backcolor:\"DarkOliveGreen\", fontsize:18});\n\n         document.getElementById(\"twr_iocanvas\").focus();\n         document.getElementById(\"twr_iocanvas\").addEventListener(\"keydown\",(ev)=&gt;{amod.keyDownCanvas(ev)});\n\n         await amod.loadWasm(\"./stdio-canvas.wasm\");\n         const r=await amod.callC([\"stdio_canvas\"]);\n         console.log(\"callC returned: \"+r);\n      }\n      catch(ex) {\n         console.log(\"unexpected exception\");\n         throw ex;\n      }\n\n   &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"examples/examples-stdio-div/","title":"stdio-div - Printf and Input Using a div Tag","text":"<p>This simple WebAssembly C program demos inputting and printing characters with a <code>div</code> tag.</p> <ul> <li>view stdio-div example running live</li> <li>View stdio-div source code</li> </ul>"},{"location":"examples/examples-stdio-div/#screen-grab-of-square-calculator","title":"Screen Grab of Square Calculator","text":""},{"location":"examples/examples-stdio-div/#c-code","title":"C Code","text":"stdio-div.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"twr-crt.h\"\n\nvoid stdio_div() {\n   char inbuf[64];\n   int i;\n\n   printf(\"Square Calculator\\n\");\n\n   while (1) {\n      printf(\"Enter an integer: \");\n      twr_mbgets(inbuf);\n      i=atoi(inbuf);\n      printf(\"%d squared is %d\\n\\n\",i,i*i);\n   }\n}\n</code></pre>"},{"location":"examples/examples-stdio-div/#html-code","title":"HTML Code","text":"<p>We are using <code>twrWasmModuleAsync</code> which integrates blocking C code into JavaScript.  <code>twrWasmModuleAsync</code> can also be used to receive key input from a <code>&lt;div&gt;</code> or <code>&lt;canvas&gt;</code> tag. </p> index.html<pre><code>&lt;head&gt;\n   &lt;title&gt;stdio-div example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n   &lt;div id=\"twr_iodiv\" style=\"background-color:LightGray;color:DarkGreen\" tabindex=\"0\"&gt;Loading... &lt;br&gt;&lt;/div&gt;\n\n   &lt;script type=\"module\"&gt;\n      import {twrWasmModuleAsync} from \"twr-wasm\";\n\n      let amod;\n\n      try {\n         amod = new twrWasmModuleAsync();\n\n         document.getElementById(\"twr_iodiv\").innerHTML =\"&lt;br&gt;\";\n         document.getElementById(\"twr_iodiv\").addEventListener(\"keydown\",(ev)=&gt;{amod.keyDownDiv(ev)});\n\n         await amod.loadWasm(\"./stdio-div.wasm\");\n         await amod.callC([\"stdio_div\"]);\n      }\n      catch(ex) {\n         amod.divLog(\"unexpected exception\");\n         throw ex;\n      }\n\n   &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"gettingstarted/basicsteps/","title":"Basic Steps To Create Your Wasm Project","text":"<p>This section describes the basic steps to integrate your TypeScript/JavaScript with C/C++ WebAssembly code.</p>"},{"location":"gettingstarted/basicsteps/#overview-of-webassembly-project","title":"Overview of WebAssembly Project","text":"<p>Your C/C++ WebAssembly project will consist of HTML (and related JavaScript or TypeScript) and C or C++ source files that are compiled into a \"<code>.wasm</code>\" binary file that is loaded as a WebAssembly module by your JavaScript.</p>"},{"location":"gettingstarted/basicsteps/#javascripttypescript-part-of-wasm-project","title":"JavaScript/TypeScript Part of Wasm Project","text":"<p>On the JavaScript side of your WebAssembly project you will use the twr-wasm JavaScript/TypeScript class <code>twrWasmModule</code> or <code>twrWasmModuleAsync</code> to load the <code>.wasm</code> module, and then call C functions in it using <code>callC</code> (more details are in the TypeScript/Javascript API section).</p>"},{"location":"gettingstarted/basicsteps/#cc-part-of-wasm-project","title":"C/C++ Part of Wasm Project","text":"<p>You will call C functions (or C++ with ' extern \"C\" ' linkage) in the <code>.wasm</code> module from your JavaScript.  You can also call JavaScript functions from your C/C++ code, but this is less common.</p> <p>There is no direct equivalent to a C \"main\".  Instead, a Wasm module provides exported C functions that you can call from JavaScript/TypeScript.  A Wasm module is more like a runtime loaded dynamic library.</p> <p>You're C/C++ code can be non-blocking or blocking.  Blocking means that it \"takes a long time\" to return.   For example, if you want to send mouse events to C code, have the code process them then return, this would be non-blocking.  Alternately, if your C code is a big loop that never returns, that would be very blocking.   You can use the twr-wasm class <code>twrWasmModuleAsync</code> to execute blocking code from JavaScript.  The example maze demonstrates both non-blocking and blocking C calls.</p> <p>Here are some examples of different types of C/C++ code:</p> <ul> <li>If you're C/C++ code does not have any direct user interface built in, it can do its calculations and return.  The FFT is an example of this.  </li> <li>If your C/C++ code uses a classic C \"UI\", where it gets keys from stdin and sends the results to stdout, you can direct stdin and stdout to a <code>&lt;div&gt;</code> or <code>&lt;canvas&gt;</code> tag.  This is explained in the stdio section.</li> <li>Your C/C++ code could be sent events from JavaScript (such mouse, key, timer, or other). This is done by simply calling a C function with the events as parameters.  The C/C++ code could then generate no output, could render to a <code>&lt;div&gt;</code> or <code>&lt;canvas&gt;</code> using stdio type C/C++ functions, or it could render to a <code>&lt;canvas&gt;</code> using 2D drawing APIs that correspond to JavaScript canvas 2D draw operations.  (Balls) is an example.</li> </ul>"},{"location":"gettingstarted/basicsteps/#steps-to-integrate-c-code-with-javascript-code","title":"Steps to integrate C code with JavaScript code","text":"<p>Here are the general steps to integrate your C with your JavaScript:</p> <ol> <li>Compile your C code with clang and link with wasm-ld to create the <code>.wasm</code> file.</li> <li>On the JavaScript side you:<ol> <li>Access twr-wasm \"ES\" modules in the normal way with <code>import</code>. </li> <li>Add a <code>&lt;div id=twr_iodiv&gt;</code> or <code>&lt;canvas id=twr_iocanvas&gt;</code> to your HTML (see stdio)</li> <li>Use <code>new twrWasmModule()</code>, followed by a call to <code>loadWasm()</code>, then one or more <code>callC()</code>.</li> <li>Alternately, use <code>twrWasmModuleAsync()</code> -- which is interchangeable with twrWasmModule, but proxies through a worker thread, and adds blocking support, including blocking char input.</li> <li>For more details, see the remainder of this documentation, or see the hello world or other exampes.</li> </ol> </li> </ol>"},{"location":"gettingstarted/charencoding/","title":"Character Encoding Support with twr-wasm","text":"<p>This section explains twr-wasm's WebAssembly support for ASCII, UTF-8, windows-1252, and UTF-32 character encoding.</p>"},{"location":"gettingstarted/charencoding/#getting-started","title":"Getting Started","text":"<p>When using C with twr-wasm, you will likely want to add this line to the start of your code: <pre><code>setlocale(LC_ALL, \"\")\n</code></pre></p> <p>This will change the C locale language to the one selected in the browser, and will enable consistent UTF-8 character encoding support.</p> <p>Without this line, the standard C runtime will (mostly) default character encoding to ASCII, as per the standard.  The exception is that just as with gcc, twr-wasm consoles support outputting UTF-8.</p>"},{"location":"gettingstarted/charencoding/#character-encodings","title":"Character Encodings","text":"<p>twr-wasm supports ASCII, UNICODE, and extended-ASCII (in the form of Windows-1252).</p> <p>These days UNICODE with UTF-8 encoding is the most popular method of displaying and encoding text. UTF-8 is popular because it has the deep character glyph definitions of UNICODE with an encoding that provides (a) the best backwards compatibility with ASCII, and (b) a compact memory footprint.  It does this at the expense of some multibyte complexities.</p> <p>UTF-8 is variable length, and uses between one to four bytes to represent any unicode code point, with ASCII compatibility in the first 128 bytes.  It is also the standard for the web, and the default for clang. But because UTF-8 uses a variable number of bytes per character it can make string manipulation in C a bit harder than ASCII, Windows-1252 or UTF-32.</p> <p>In this document you will see the term \"locale\". This term originated (at least as its commonly used in programming) in the standard C library, and is also used in the standard C++ library (libc++ in twr-wasm).  A locale refers to a region of the world, along with a specific character encoding. The twr-wasm standard c runtime uses a label akin to this to define a locale: <code>en-US.UTF-8</code>. Of note is that libc++ and the standard C runtime have different domains for their locales (ie, they don't directly impact each other).  You can learn more about locales by searching the internet. </p> <p>twr-wasm C locales support ASCII, UTF-8 or windows-1252 character encoding.  UTF-16/32 are not supported as a std c lib locale setting, but functions are provided to convert utf-32 (unicode code points) to and from ASCII, UTF-8, and windows-1252 \"code pages\" (there are other miscellaneous utf-32 based functions as well.)</p> <p>Although twr-wasm's standard c library locale doesn't support utf-32 directly, you can use int arrays (instead of byte arrays) to hold utf-32 strings, and then convert them to/from utf-8 with the help of the provided functions for this purpose.  Alternately, you can use libc++, which has classes that directly support utf-16 and utf-32.</p>"},{"location":"gettingstarted/charencoding/#windows-compatibility-with-windows-1252","title":"Windows Compatibility with Windows-1252","text":"<p>Windows-1252 is the default character encoding on Windows computers in many countries - particularly the Americas and western Europe -- and particularly when using MSVC. Linux, clang, gcc, and the web commonly default in some way to UTF-8 character encoding.  Windows-1252 is an extension of ASCII that uses a single byte per character.  This makes it easier than UTF-8 from a programmers perspective, but it doesn't represent as many characters. It is supported by twr-wasm to make it easier to port legacy C code, windows code, as well as a simpler alternative to UTF-8.</p> <p>twr-wasm supports Windows-1252, and you can enable it like this:</p> <pre><code>setlocale(LC_ALL, \".1252\")\n</code></pre> <p>This will set the locale to the default browser language, and character encoding to Windows-1252.</p> <p>1252 String Literals These days text editors generally default to UTF-8.  In order to use windows-1252  source code and/or string literals, such as <code>const char * str=\"\u20ac100\"</code> you may need to: </p> <ul> <li>Configure your text editor to save in Windows-1252/ISO-8859-1 format (instead of UTF-8)</li> <li>use compiler flags like <code>--finput-charset</code> and <code>-fexec-charset</code></li> </ul> <p>By default, the Microsoft Visual Studio C compiler (MSVC) does not treat string literals as UTF-8. Instead, it treats them as being encoded in the current code page of the system, which is typically Windows-1252 on western european language Windows systems.  twr-wasm is designed to work with clang, which does default to utf-8, so if you are compiling code written for MSVC, and you use extend character sets (non ASCII), you may need to adjust your compiler settings with the flags mentioned above.</p>"},{"location":"gettingstarted/charencoding/#more","title":"More","text":"<p>For more details see Localization Reference for twr-wasm</p>"},{"location":"gettingstarted/compiler-opts/","title":"Compiling, Linking, and Memory Options","text":"<p>This section described how to use clang to compile C/C++ code for WebAssembly, and how to link your files into a .wasm module, when using twr-wasm.</p> <p>twr-wasm lets you use clang directly, without a wrapper.  This section describes the needed clang compile options and the wasm-ld link options.  You can also take a look at the example makefiles.</p>"},{"location":"gettingstarted/compiler-opts/#c-clang-compiler-options-targeting-wasm","title":"C clang Compiler Options Targeting Wasm","text":"<p>When compiling C code with clang for use with Wasm and twr-wasm, use these clang options: <pre><code> --target=wasm32 -nostdinc -nostdlib -isystem  ../../include\n</code></pre></p> <p>-isystem should point to the folder <code>twr-wasm/include</code>.  The option line above uses a relative link to <code>include</code> that works if your project is a sub folder in the <code>examples</code> folder.</p> <p>If you installed using npm, then includes are at <code>node_modules/twr-wasm/include</code> (see the installation note on npm).</p> <p>You will also need to link to <code>twr.a</code> (explained in the linking section below).</p>"},{"location":"gettingstarted/compiler-opts/#c-clang-compiler-options-targeting-wasm_1","title":"C++ clang Compiler Options Targeting Wasm","text":"<p>When compiling C++ code with clang for use with Wasm and twr-wasm, use these clang options: <pre><code> --target=wasm32 -fno-exceptions -nostdlibinc -nostdinc -nostdlib -isystem  ../../include\n</code></pre></p> <p>You will also need to link to <code>twr.a</code> and <code>libc++.a</code> (explained in the linking section below).</p> <p>Be sure to adjust the path to <code>twr.a</code>, <code>libc++.a</code>, and the <code>include</code> folder as needed (see above note in the C section).</p>"},{"location":"gettingstarted/compiler-opts/#wasm-ld-linker-options","title":"wasm-ld Linker Options","text":"<p>Use the wasm-ld linker directly with twr-wasm.</p> <p>All of the twr-wasm functions are staticly linked from the library <code>lib-c/twr.a</code>.  There is also a version ( <code>lib-c/twrd.a</code> ) of twr-wasm library available with debug symbols.  One of these two static libraries should be added to the list of files to link (normally this is <code>twr.a</code>).  Both versions are built with asserts enabled.  <code>twr.a</code> is built with <code>-O3</code>.  <code>twrd.a</code> is built with <code>-g -O0</code>.</p> <p>To use <code>libc++</code>, link to <code>libc++.a</code> (see the tests-libcxx example makefile).</p> <p>C functions that you wish to call from JavaScript should either have an <code>-export</code> option passed to <code>wasm-ld</code>, or you can use the <code>__attribute__((export_name(\"function_name\")))</code> option in your C function definition.</p> <p>All exported functions to JavaScript should be C linkage (<code>extern \"C\"</code> if using C++).</p> <p>wasm-ld should also be passed the following options:</p> <p>If Using twrWasmModule: <pre><code>--no-entry --initial-memory=&lt;size&gt; --max-memory=&lt;size&gt;\n</code></pre></p> <p>If Using twrWasmModuleAsync: <pre><code>--no-entry --shared-memory --no-check-features --initial-memory=&lt;size&gt; --max-memory=&lt;size&gt;\n</code></pre></p>"},{"location":"gettingstarted/compiler-opts/#memory-options-for-webassembly","title":"Memory Options for WebAssembly","text":"<p>You set the memory size for your module (<code>WebAssembly.Memory</code>) using <code>wasm-ld</code> options as follows (this examples sets your Wasm memory to 1MB).  The memory size should be a multiple of 64*1024 (64K) chunks.</p> <p>if using <code>twrWasmModule</code>: <pre><code>--initial-memory=1048576 --max-memory=1048576\n</code></pre></p> <p>If you are using <code>twrWasmModuleAsync</code>, shared memory must also be enabled. Like this: <pre><code>--shared-memory --no-check-features --initial-memory=1048576 --max-memory=1048576\n</code></pre></p> <p>See this production note on using shared memory.</p> <p>The memory is an export out of the <code>.wasm</code> into the JavaScript code.  There is no support for automatically growing memory.</p> <p>You can change your C/C++ stack size from the default 64K with the following <code>wasm-ld</code> option.   This example sets the stack at 128K <pre><code> -z stack-size=131072\n</code></pre></p> <p>You can print your module memory map, heap stats, and stack size using the function from C: <pre><code>void twr_mem_debug_stats(struct IoConsole* outcon);\n</code></pre> You can call it from Javascript with the output sent to the debug console (stderr) like this: <pre><code>twrWasmModule/Async.callC([\"twr_wasm_print_mem_debug_stats\"])\n</code></pre></p> <p>twrWasmModule and twrWasmModuleAsync expose <code>malloc</code> as an async function, as well as the WebAssembly Module memory as: <pre><code>async malloc(size:number);\n\nmemory?:WebAssembly.Memory;\nmem8:Uint8Array;\nmem32:Uint32Array;\nmemD:Float64Array;\n</code></pre> to call <code>free</code> from JavaScript (you probably won't need to), you can use: <pre><code>twrWasmModule/Async.callC(\"twr_free\", index);  // index to memory to free, as returned by malloc\n</code></pre></p>"},{"location":"gettingstarted/helloworld/","title":"Create and Run WebAssembly Hello World","text":"<p>This section shows you, step by step, how to to create a C \"hello world\" program for WebAssembly (Wasm) with twr-wasm, C, HTML, and JavaScript.</p> <p>You will learn how to:</p> <ul> <li>Create the helloworld.c file</li> <li>Create the index.html file</li> <li>Compile the helloworld.c code with <code>clang</code></li> <li>Link the helloworld.o and twr.a files with <code>wasm-ld</code> to create a helloworld.wasm file</li> <li>Set the needed library and include paths to allow the twr-wasm libraries to be discovered</li> <li>Create an optional Makefile</li> <li>Execute the \"hello world\" program using a local web server or directly with VS Code and Chrome</li> </ul> <p>You can find code for a hello world example in the folder examples\\helloworld.  It is similar, but not identical to this walk through.  The primary differences are the paths for lib-c, lib-js, and include.</p>"},{"location":"gettingstarted/helloworld/#step-0-installation","title":"Step 0: Installation","text":"<ul> <li>prerequisites: install clang, wasm-ld, and python or VS Code (or both)</li> <li>Create a folder for your project, such as <code>hello-proj</code></li> <li><code>cd</code> into <code>hello-proj</code></li> <li><code>npm install twr-wasm</code></li> <li>your folder structure should now look similar to this: <pre><code>hello-proj\\\n\u251c\u2500\u2500package.json\n\u2514\u2500\u2500node_modules\\\n   \u2514\u2500\u2500twr-wasm\\\n      \u251c\u2500\u2500examples\\\n      \u2514\u2500\u2500include\\\n      \u2514\u2500\u2500lib-c\\\n      \u2514\u2500\u2500lib-js\\\n      \u2514\u2500\u2500LICENSE\n      \u2514\u2500\u2500package.json\n      \u2514\u2500\u2500readme.md\n</code></pre></li> </ul>"},{"location":"gettingstarted/helloworld/#step-1-create-the-c-code","title":"Step 1: Create the C code","text":"<p>Create a file <code>helloworld.c</code> in <code>hello-proj</code> helloworld.c<pre><code>#include &lt;stdio.h&gt;\n\nvoid hello() {\n   printf(\"hello world\\n\");\n}\n</code></pre></p>"},{"location":"gettingstarted/helloworld/#step-2-create-the-html","title":"Step 2: Create the HTML","text":"<p>Create a file <code>index.html</code> in <code>hello-proj</code> index.html<pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n   &lt;title&gt;Hello World&lt;/title&gt;\n\n   &lt;script type=\"importmap\"&gt;\n   {\n      \"imports\": {\n      \"twr-wasm\": \"./node_modules/twr-wasm/lib-js/index.js\"\n      }\n   }\n   &lt;/script&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n   &lt;div id=\"twr_iodiv\"&gt;&lt;/div&gt;\n\n   &lt;script type=\"module\"&gt;\n      import {twrWasmModule} from \"twr-wasm\";\n\n      const mod = new twrWasmModule();\n      await mod.loadWasm(\"./helloworld.wasm\");\n      await mod.callC([\"hello\"]);\n   &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <p>This example uses Import Maps, which are used when not using a bundler like WebPack or Parcel.  For smaller projects, this can be simpler with a more clear debugging and development environment.  This is the approach we will use for this example (no bundler).</p> <p>The path in the <code>importmap</code> section of <code>index.html</code> should point to the location where you installed <code>twr-wasm/lib-js</code>.  The path above is correct for this project example with the indicated folder structure.</p>"},{"location":"gettingstarted/helloworld/#step-3-compile-your-c-code-to-create-your-wasm-file","title":"Step 3: Compile your C code to create your .wasm file","text":"<pre><code>cd hello-proj\nclang --target=wasm32 -nostdinc -nostdlib -isystem ./node_modules/twr-wasm/include -c  helloworld.c -o helloworld.o\nwasm-ld  helloworld.o ./node_modules/twr-wasm/lib-c/twr.a -o helloworld.wasm  --no-entry --initial-memory=131072 --max-memory=131072 --export=hello \n</code></pre> <p>The path to <code>twr.a</code> and to <code>include</code>  should match your installation.  The above path is correct for this example.</p> <p>As an alternate to executing clang and wasm-ld from the shell, here is a Makefile that will work for this example:</p> Makefile<pre><code>CC := clang\nTWRCFLAGS := --target=wasm32 -nostdinc -nostdlib -isystem  ./node_modules/twr-wasm/include\nCFLAGS := -c -Wall -O3 $(TWRCFLAGS)\nCFLAGS_DEBUG := -c -Wall -g -O0  $(TWRCFLAGS)\n\n.PHONY: default\n\ndefault: helloworld.wasm\n\nhelloworld.o: helloworld.c\n    $(CC) $(CFLAGS)  $&lt; -o $@\n\nhelloworld.wasm: helloworld.o \n    wasm-ld  helloworld.o ./node_modules/twr-wasm/lib-c/twr.a -o helloworld.wasm \\\n        --no-entry --initial-memory=131072 --max-memory=131072 \\\n        --export=hello \n</code></pre> <p>Copy the above into a file named <code>Makefile</code> and execute with <code>make</code> (or <code>mingw32-make</code> in windows).</p>"},{"location":"gettingstarted/helloworld/#step-4-load-and-execute-your-web-page","title":"Step 4: Load and execute your web page","text":"<p>The two easiest ways to load and execute your <code>index.html</code> web page locally are:</p>"},{"location":"gettingstarted/helloworld/#option-a-run-a-local-web-server","title":"Option A: Run a local web Server","text":"<p>You can run a local server to view your helloworld program.  </p> <ul> <li>Copy the file server.py from the examples folder to your <code>hello-proj</code> folder (where your <code>index.html</code> resides).  </li> <li>Execute with the shell command <code>python server.py</code>.</li> <li>Open your web browser and browse to <code>http://localhost:8000/index.html</code></li> <li>You should see 'Hello World' in the browser window!</li> </ul> <p>At this pont your folder structure should look like this:</p> <pre><code>hello-proj\\\n\u2514\u2500\u2500node_modules\\\n\u2514\u2500\u2500helloworld.c\n\u2514\u2500\u2500helloworld.o\n\u2514\u2500\u2500helloworld.wasm\n\u2514\u2500\u2500index.html\n\u2514\u2500\u2500Makefile\n\u2514\u2500\u2500package.json\n\u2514\u2500\u2500server.py\n</code></pre>"},{"location":"gettingstarted/helloworld/#option-b-vs-code-launchjson","title":"Option B: VS Code launch.json","text":"<p>Alternately, you can launch chrome without a local web server.  Add an entry similar to the following to  <code>hello-proj\\.vscode\\launch.json</code>.  This assumes your workspaceFolder is <code>hello-proj</code>.</p> launch.json<pre><code>{\n    \"configurations\": [\n    {\n        \"name\": \"Launch Chrome Hello, World!\",\n        \"request\": \"launch\",\n        \"type\": \"chrome\",\n        \"runtimeArgs\": [\n            \"--allow-file-access-from-files\",\n            \"--autoplay-policy=no-user-gesture-required\",\n            \"--enable-features=SharedArrayBuffer\"\n         ],\n         \"file\": \"${workspaceFolder}/index.html\",\n         \"cwd\": \"${workspaceFolder}/\",\n    }\n    ]\n}\n</code></pre> <p>Once you have created this file, you:</p> <ul> <li>select the Run and Debug icon on left</li> <li>Select the green play icon at the top, with \"Launch Chrome Hello, World!\" selected</li> <li>Chrome should launch, and you should see 'Hello World' in the browser window!</li> </ul> <p><code>--autoplay-policy=no-user-gesture-required</code> and <code>--enable-features=SharedArrayBuffer</code> are not required for this simple \"hello world\" example, but will be needed if you request user input or you are using <code>twrWasModuleAsync</code>.</p>"},{"location":"gettingstarted/helloworld/#see-live-version","title":"See live version","text":"<p>You can find a live link to hello world on this page.</p>"},{"location":"gettingstarted/helloworld/#next-steps-after-hello-world","title":"Next steps after hello world","text":"<p>A good way to get your own code up and running is to copy one of the examples, get it to build and run, then start modifying it.  Note you will need to modify the paths for <code>include</code>, <code>lib-js</code>, <code>lib-c</code>, etc. based on your project structure.  The examples are all setup with relative paths assuming the folder structure <code>twr-wasm\\examples\\&lt;example&gt;</code></p> <p>The examples include MakeFiles.</p> <p>\"Hello World\" uses the twr-wasm class <code>twrWasmModule</code>.   If you wish to use C blocking functions, such as <code>twr_getc32</code> or <code>twr_sleep</code>, you should use <code>twrWasmModuleAsync</code>.  This square calculator example shows how to do this.  </p> <p>If you wish to build an app that makes non-block calls into C, the balls example shows how to do this. The maze example uses a combination of blocking and non-blocking C functions.</p>"},{"location":"gettingstarted/installation/","title":"Installing twr-wasm","text":"<p>A simple way to install twr-wasm is: <pre><code>npm install twr-wasm\n</code></pre></p> <p>See the \"Hello World walk through\" in the following section for more specifics.</p> <p>There are actually two methods of installation with different pros and cons:</p> <ul> <li><code>npm install</code> will install everything necessary to build your software: built libraries (lib-js, lib-c) and includes.  In addition the examples are installed.</li> <li><code>git clone</code> will copy the above as well as the source and VS Code settings.</li> </ul> <p>When using <code>twr-wasm</code> your applications needs to access both JavaScript and C twr-wasm libraries.  This is explained in the installation sections below, as well as in the Hello World walk through.</p>"},{"location":"gettingstarted/installation/#npm-install","title":"npm install","text":"<p><pre><code>npm install twr-wasm\n</code></pre> After installation from npm, you will have a folder structure like this:</p> <p><pre><code>node_modules\\\n   twr-wasm\\\n      examples\\\n      include\\\n      lib-c\\\n      lib-js\\\n      LICENSE\n      package.json\n      readme.md\n</code></pre> The JavaScript and TypeScript exports are in <code>lib-js</code> and should be found by VS Code, TypeScript or your bundler as usual when using a statement like <code>import {twrWasmModule} from \"twr-wasm\"</code>.  </p> <p>The C library (<code>twr.a</code>) that you will need to link your C/C++ program to is found in the <code>libs-c</code> folder, and the C/C++ include files that you will need to use in your C/C++ program are found in the <code>include</code> folder.  You will need to use paths to to these folders in your makefile. See the Hello World walk through for details. </p> <p>There is no real downside to this installation method, except possibly: (1) it does not include source code (use git clone for that), and (b) the C libraries are buried inside your node_modules.</p>"},{"location":"gettingstarted/installation/#git-install","title":"git install","text":"<pre><code> git clone https://github.com/twiddlingbits/twr-wasm\n</code></pre> <p>This method of installation installs the complete code base, including source and built binaries.   </p> <p>The primary downside to this method is that the JavaScript side of twr-wasm will not be placed in a node_modules folder. This will create a little extra work to configure a bundler, TypeScript or VS Code to find the location of imports.</p> <p>There are a few solutions to this.  For example, in the provided Hello World example, a <code>package.json</code> file with an <code>alias</code> entry is used.  This syntax is supported by the Parcel bundler:</p> <pre><code>{\n   \"@parcel/resolver-default\": {\n      \"packageExports\": true\n   },\n   \"alias\": {\n      \"twr-wasm\": \"../../lib-js/index.js\"\n   },\n   \"dependencies\": {\n      \"twr-wasm\": \"^2.0.0\"\n   }\n}\n</code></pre> <p>The FFT example uses the <code>paths</code> entry in the <code>tsconfig.json</code> file.  This is found by TypeScript, VS Code and the Parcel bundler.  This is probably the best solution if you are using TypeScript.</p> <pre><code>\"paths\": {\n   \"twr-wasm\": [\"./../../lib-js/index\"]\n}\n</code></pre> <p>The paths for <code>alias</code> and <code>paths</code> shown above are correct for the included examples, but will likely need to be adjust for your project.</p>"},{"location":"gettingstarted/installation/#note-on-examples","title":"Note on Examples","text":"<p>All of the examples have makefiles that use a relative path for <code>twr.a</code> and <code>includes</code>. These paths will work fine if your code is in an examples sub-folder as a peer to the other examples.  But assuming your code is in your own project folder elsewhere, you will need to determine the correct path to <code>twr.a</code> and <code>includes</code> for your project's makefile.  Details on how to do this can be found in the following sections: Hello World walk through and the Compiler and Linker Options section.</p>"},{"location":"gettingstarted/installation/#clang-and-wasm-ld","title":"clang and wasm-ld","text":"<p>To build C/C++ code for use in your Wasm project, you will need to install clang and the wasm-ld linker.  If you are using Windows, more details can be found at the end of the Building Source section.</p>"},{"location":"gettingstarted/installation/#python","title":"python","text":"<p>To use the included <code>examples\\server.py</code> you will need to install python.  server.py is a simple HTTP server for local testing that sets the correct CORS headers for <code>twrWasmModuleAsync</code>.  As explained in the following Hello World walk through, you can alternately execute HTML files directly using VS Code and Chrome.</p>"},{"location":"gettingstarted/parameters/","title":"Passing Function Parameters to WebAssembly","text":"<p>This article describes techniques to transfer data between JavaScript/TypeScript and C/C++ when using WebAssembly. It delves a bit \u201cunder the covers\u201d to explain how this works when you use a library like twr-wasm or Emscripten. In this article, I am using twr-wasm for the examples. Emscripten does something similar.</p> <p>For an example that illustrates the concepts discussed here, see: the callC example.</p>"},{"location":"gettingstarted/parameters/#webassembly-virtual-machine-intrinsic-capabilities","title":"WebAssembly Virtual Machine Intrinsic Capabilities","text":"<p>The WebAssembly VM (often referred to as a Wasm \u201cRuntime\u201d) is limited to passing numbers between C functions and the Wasm host (I\u2019ll assume that\u2019s JavaScript for this document). In other words, if you are using the most basic WebAssembly capabilities provided by JavaScript, such as <code>WebAssembly.Module</code>, <code>WebAssembly.Instance</code>, and <code>instance.exports</code>, your function calls and return types can only be:</p> <ul> <li>Integer 32 bit</li> <li>Floating point 32 or 64 bit</li> </ul> <p>The WebAssembly spec supports: i32, i64, f32, and f64. But JavaScript doesn\u2019t support 64-bit integers without using the <code>BigInt</code> type. The JavaScript Number is always a <code>Float64</code>, known as a \u201cdouble\u201d in C/C++. A JavaScript Number can be converted to a <code>Float32</code> or an <code>Integer32</code>.</p> <p>When using 32-bit WebAssembly (by far the most common default), and you call a C function from JavaScript without using any \u201chelper\u201d libraries, the following parameter types can be passed:</p> <ul> <li>Integer 32: JavaScript <code>Number</code> type is converted to an <code>Integer32</code> and passed to C when the C function prototype specifies a signed or unsigned int, long, int32_t, or a pointer type. All of these are 32 bits in length in wasm32.</li> <li>JavaScript <code>Number</code> type is passed as a <code>Float64</code> when the C function prototype specifies a double.</li> <li>JavaScript <code>Number</code> type is converted to a Float32 when the C function prototype specifies a float.</li> </ul> <p>The same rules apply to the return types.</p>"},{"location":"gettingstarted/parameters/#passing-strings-from-javascript-to-cc-webassembly","title":"Passing Strings from JavaScript to C/C++ WebAssembly","text":"<p>Although you can use the technique I am about to describe here directly (by writing your own code), it is generally accomplished by using a third-party library such as twr-wasm or Emscripten. These libraries handle the nitty-gritty for you. To pass a string from JavaScript/TypeScript to a WebAssembly module, the general approach is to:</p> <ul> <li>Allocate memory for the string inside the WebAssembly memory. This is typically done with malloc. malloc returns a pointer, which is an index into the WebAssembly Memory.</li> <li>Copy the string to this allocated memory. In the case of twr-wasm, this copying also converts the character encoding as necessary, for example, to UTF-8.</li> <li>Pass the malloc'd memory index to your function as an integer (which is accepted as a pointer by C code).</li> <li>In the case of twr-wasm, this is handled for you by the <code>callC</code> function.</li> </ul> <pre><code>callC([\"my_function\", \"this is my string\"]);\n</code></pre> <p>Under the covers, callC will execute code like this:</p> <p><pre><code>async putString(sin, codePage = codePageUTF8) {\n    const ru8 = this.stringToU8(sin, codePage);  // ru8 is of type Uint8Array\n    const strIndex = await this.malloc(ru8.length + 1);\n    this.mem8.set(ru8, strIndex);  // mem8 is of type Uint8Array and is the Wasm Module\u2019s Memory\n    this.mem8[strIndex + ru8.length] = 0;\n    return strIndex;\n}\n</code></pre> <code>this.malloc</code> is the standard C runtime <code>malloc</code> function, provided by twr-wasm, and linked into your <code>.wasm</code> code that is loaded into the WebAssembly Module. Likewise, twr-wasm will call <code>free</code> after the function call is executed.</p>"},{"location":"gettingstarted/parameters/#returning-a-string-from-cc-webassembly-to-javascript","title":"Returning a String from C/C++ WebAssembly to JavaScript","text":"<p>Returning a string from C to JavaScript is the reverse of passing in a string from JavaScript to C. When the \u201craw\u201d WebAssembly capabilities are used (<code>WebAssembly.Module</code>, etc.) and your C code looks like this:</p> <pre><code>return(\"my string\");\n</code></pre> <p>The WebAssembly VM and JavaScript host will cause your JavaScript to receive an unsigned 32-bit integer. This is the pointer to the string, cast to an unsigned 32-bit integer. This integer is an index into the WebAssembly Memory.</p> <p>twr-wasm provides a function to pull the string out of WebAssembly Memory and convert the character encoding to a JavaScript string. JavaScript strings are Unicode 16, but twr-wasm supports ASCII, UTF-8, and windows-1252 string encoding. When extracted and converted, a copy of the string is made.</p> <pre><code>const retStringPtr = await mod.callC([\"ret_string_function\"]);\nconsole.log(mod.getString(retStringPtr));\n</code></pre> <p>The <code>retStringPtr</code> is an integer 32 (but converted to a JavaScript <code>Number</code>, which is <code>Float64</code>). This integer is an index into the WebAssembly Memory.</p>"},{"location":"gettingstarted/parameters/#passing-structs-from-javascript-to-cc-webassembly","title":"Passing Structs from JavaScript to C/C++ WebAssembly","text":"<p>To pass a C struct (or receive a C struct), the same techniques used for strings can be used. The primary new complexity is that each struct entry\u2019s memory address needs to be calculated. And when calculating the WebAssembly Memory indices for the struct entries, C structure padding must be accounted for. </p> <p>In clang, if you declare this structure in your C code:</p> <pre><code>struct test_struct {\n    int a;\n    char b;\n    int *c;\n};\n</code></pre> <ul> <li>The first entry, <code>int a</code>, will be at offset 0 in memory.</li> <li>The second entry, <code>char b</code>, will be at offset 4 in memory. This is expected since the length of an int is 4 bytes.</li> <li>The third entry, <code>int *c</code>, will be at offset 8 in memory, not at offset 5 as you might expect. The compiler adds three bytes of padding to align the pointer to a 4-byte boundary.</li> </ul> <p>This behavior is dependent on your compiler, cpu, and whether you are using 32 or 64-bit architecture. For wasm32 with clang:</p> <ul> <li>char is 1 byte aligned</li> <li>short is 2 byte aligned</li> <li>pointers are 4 byte aligned</li> <li>int, long, int32_t are 4 byte aligned</li> <li>double (<code>Float 64</code>) is 8-byte aligned</li> </ul> <p>If you are not familiar with structure padding, there are many articles on the web.</p> <p>Alignment requirements are why twr-wasm <code>malloc</code> (and GCC <code>malloc</code> for that matter) aligns new memory allocations on an 8-byte boundary.</p> <p>When accessing a C struct in JavaScript/TypeScript, you have to do a bit of arithmetic to find the correct structure entry. For example, using twr-wasm with the above <code>struct test_struct</code>, you access the elements like this using JavaScript:</p> <pre><code>const structMem = await mod.callC([\"get_test_struct\"]);\nconst structIndexA = 0;\nconst structIndexB = 4;\nconst structIndexC = 8;\nconst valA = mod.getLong(structMem + structIndexA);\nconst valB = mod.mem8[structMem + structIndexB];\nconst intValPtr = mod.getLong(structMem + structIndexC);\nconst intVal = mod.getLong(intValPtr);\n</code></pre> <p>You can see the additional complexity of de-referencing the <code>int *</code>.</p> <p>For an example of allocating a C struct in JavaScript, see this example.</p>"},{"location":"gettingstarted/parameters/#passing-arraybuffers-from-javascript-to-cc-webassembly","title":"Passing ArrayBuffers from JavaScript to C/C++ WebAssembly","text":"<p>twr-wasm provides helper functions to pass ArrayBuffers to and from C/C++. The technique here is similar to that used for a <code>struct</code>, with the following differences:</p> <ul> <li><code>ArrayBuffers</code> have entries of all the same length, so no special <code>struct</code> entry math is needed.</li> <li>When an <code>ArrayBuffer</code> is passed to a function, the function receives a pointer to the <code>malloc</code> memory. If the length is not known by the function, the length needs to be passed as a separate parameter.</li> <li>When the C function returns, any modifications made to the memory are reflected back into the <code>ArrayBuffer</code>.</li> </ul> <p>Here is an example:</p> <pre><code>let ba = new Uint8Array(4);\nba[0] = 99; ba[1] = 98; ba[2] = 97; ba[3] = 6;\nconst ret_sum = await mod.callC([\"param_bytearray\", ba.buffer, ba.length]);\n</code></pre> <p>See this example for the complete example.</p>"},{"location":"gettingstarted/parameters/#passing-a-javascript-object-to-webassembly","title":"Passing a JavaScript Object to WebAssembly","text":"<p>To pass a JavaScript object to WebAssembly, the entries need to be converted to a C struct.  And the C struct can then be passed (or returned) from WebAssembly, as described in the section on C structs.</p> <p>One minor item of note is that a JavaScript Object is an Associative Array which has no intrinsic order (a JavaScript <code>Map</code> does retain its insertion order). Structs do have an order.   </p> <p>A JavaScript object can contain entries that are of more complexity than simple C data types.  In other words, an object containing only simple data types like:</p> <pre><code>const a = 'foo';\nconst b = 42;\nconst object2 = { a: a, b: b };\n</code></pre> <p>Is straightforward to convert to a C struct (using the above techniques): <pre><code>struct object2 {\n    const char* a;\n    int b;\n};\n</code></pre></p> <p>But when a JavaScript object contains more complicated data types, it gets more complicated: <pre><code>const a = 'foo';\nconst b = 42;\nconst map = new Map();\nmap1.set('a', 1);\nmap1.set('b', 2);\nmap1.set('c', 3);\nconst object2 = { a: a, b: b, c: map };\n</code></pre></p> <p>In this case, you are going to have to do more work.  An approach is to use the libc++ <code>map</code> class, which is similar to the JavaScript <code>Map</code>.  You could also perhaps use the libc++ <code>vector</code>.  </p> <p>To handle this more complicated JavaScript object with a <code>Map</code> entry, an approach is to export functions from WebAssembly to create and add entries to the libc++ <code>map</code> (you need to use <code>extern 'C'</code> to export these C++ access functions as C functions).  In otherworld, you might export from your Wasm Module C functions like this:</p> <pre><code>void* createMap();   // return an unsigned long Map ID\nvoid addIntToMap(void* mapID, int newInt);\n</code></pre> <p>You would then use these functions in JavaScript to build your C++ <code>map</code>.  JavaScript would access this <code>map</code> using the <code>unsigned long</code> identifier (the <code>void *</code> returned by <code>createMap</code>).  After creating and adding entries to the <code>map</code>, you would set this MapID to <code>object2.c</code>.</p> <p>There are alternative approaches.  For example, you could convert the JavaScript <code>Map</code> to a C struct, by enumerating every entry in the <code>Map</code>.  Your C struct might look like: ` <pre><code>struct entry {\n    char* name;\n    int value;\n};\n\nstruct mapUnroll {\n    int MapLen;\n    struct entry* entries[];\n};\n</code></pre></p> <p>This approach is probably even more work, less general purpose, and less efficient.</p>"},{"location":"gettingstarted/parameters/#summary","title":"Summary","text":"<p>I hope this has demystified how JavaScript values are passed to and from WebAssembly.</p>"},{"location":"gettingstarted/stdio/","title":"Stdio with C/C++ WebAssembly","text":"<p>This section describes how you can direct C/C++ standard input or output to or from a div or canvas tag in a twr-wasm C/C++ Wasm project.</p>"},{"location":"gettingstarted/stdio/#use-div-or-canvas-tag","title":"Use div or canvas tag","text":"<p>Standard input and output can be directed to a <code>&lt;div&gt;</code> or to a <code>&lt;canvas&gt;</code> HTML tag.  Using a <code>&lt;div&gt;</code> is a simple way to display the output of a <code>printf</code>, or to get input from <code>getc</code> (using traditional standard library blocking input). </p> <p>A <code>&lt;canvas&gt;</code> tag can be used by twr-wasm to create a simple ANSI style terminal or console.  This windowed terminal supports the same streamed output and input features as a does a div tag, but also supports x,y coordinates, colors, and other features. The window console supports chunky (low res) graphics (each character cell can be used as a 2x3 graphic array). </p> <p>Another difference between a div stream and a canvas stream, is that a div tag will grow as more text is added.  On the other hand, a canvas tag has a fixed width and height, and additional text will cause a scroll as it fills up the window.</p> <p>Unicode characters are supported by <code>stdout</code> and <code>stdin</code> (see Character Encoding Support with twr-wasm).</p>"},{"location":"gettingstarted/stdio/#div-or-canvas-tag-discovery-order","title":"div or canvas tag discovery order","text":"<p>If you wish to use a div or canvas tag for stdio when using twr-wasm, in your HTML file add a <code>&lt;div id=\"twr_iodiv\"&gt;</code> or alternately a <code>&lt;canvas id=\"twr_iocanvas\"&gt;</code> tag.</p> <ul> <li><code>&lt;div id=\"twr_iodiv\"&gt;</code> will be used for <code>stdin</code> and <code>stdout</code> if found.</li> <li><code>&lt;canvas id=\"twr_iocanvas\"&gt;</code> will be used for <code>stdin</code> and <code>stdout</code> if it exists and no div found. </li> <li>if neither of the above <code>&lt;div&gt;</code> or <code>&lt;canvas&gt;</code> is defined in your HTML, then <code>stdout</code> is sent to the debug console in your browser. And <code>stdin</code> is not available.</li> </ul> <p>Note that you can also add a <code>&lt;canvas id=\"twr_d2dcanvas\"&gt;</code> to your HTML to define a canvas to be used by twr-wasm's 2D drawing APIs.</p>"},{"location":"gettingstarted/stdio/#stderr","title":"stderr","text":"<p><code>stderr</code> streams to the browser's debug console.</p>"},{"location":"gettingstarted/stdio/#examples","title":"Examples","text":"Name View Live Link Source Link stdin and stdout to <code>&lt;div&gt;</code> View square demo Source simple \"terminal\" via <code>&lt;canvas&gt;</code> View hello world demo Source \"cli\" with a <code>&lt;canvas&gt;</code> stdio View CLI demo using libc++ Source"},{"location":"gettingstarted/stdio/#io-console-docs","title":"IO Console Docs","text":"<p><code>stdin</code>,  <code>stdout</code>, and <code>stderr</code> are abstracted by a twr-wasm IO Consoles.</p>"},{"location":"gettingstarted/stdio/#utf-8-or-windows-1252","title":"UTF-8 or Windows-1252","text":"<p><code>Stdin</code> and <code>stdout</code> can support UTF-8 or Windows-1252 character encodings (see localization)</p>"},{"location":"gettingstarted/stdio/#includes","title":"Includes","text":"<p><code>#include &lt;stdio.h&gt;</code> to access <code>stdout</code>, <code>stdin</code>, <code>stderr</code>, and <code>FILE</code>.</p> <p>FILE is supported for user input and output, and for stderr.  File i/o (to a filesystem) is not currently supported.</p>"},{"location":"gettingstarted/stdio/#stdout-and-stderr-functions","title":"stdout and stderr functions","text":"<p>You can use these functions to output to the standard library defines <code>stderr</code> or <code>stdout</code>: <pre><code>fputc, putc, vfprintf, fprintf, fwrite\n</code></pre></p> <p>You can also use the IO Console functions referenced above to send to <code>stdout</code> and <code>stderr</code>.</p> <p>These functions go to stdout: <pre><code>printf, vprintf, puts, putchar\n</code></pre></p> <p>Note that when characters are sent to the browser console using <code>stderr</code> they will not render to the console until a newline, return, or ASCII 03 (End-of-Text) is sent.</p> <p>For example: <pre><code>#include &lt;stdio.h&gt;\n\nfprintf(stderr, \"hello over there in browser debug console land\\n\");\n</code></pre></p> <p>A more common method to send output to the debug console is to use <code>twr_conlog</code>. See General C API Section.</p>"},{"location":"gettingstarted/stdio/#stdin-functions","title":"stdin functions","text":"<p>Reading from <code>stdin</code> is blocking, and so <code>twrWasmModuleAsync</code> must be used to receive keys from stdin. See the next section for the needed JavaScript line.</p> <p>You can get characters from <code>stdin</code> with any of these functions:</p> <ul> <li><code>io_mbgets</code> - get a multibyte string from the stdin IoConsole using the current locale character encoding </li> <li><code>io_getc32</code> - gets a 32 bit unicode code point the stdin IoConsole</li> <li><code>io_mbgetc</code> - get a single multibyte character from the stdin IoConsole using the current locale character encoding</li> <li><code>twr_mbgets</code> - similar to <code>io_mbgets</code>,  but assumes <code>stdin</code> is the input source</li> <li><code>getc</code> (sames as <code>fgetc</code>) - get a single byte from a FILE * (struct IoConsole *) -- which should be stdin.  Returning ASCII or extended ASCII (window-1252 encoding).</li> </ul>"},{"location":"gettingstarted/stdio/#javascript-needed-for-char-input","title":"JavaScript needed for char input","text":"<p><code>twrWasmModuleAsync</code> must be used to receive keys from stdin.  In addtion, you should add a line like the following to your JavaScript for stdin to work:</p> <p>If using <code>twr_iodiv</code> <pre><code>document.getElementById(\"twr_iodiv\").addEventListener(\"keydown\",(ev)=&gt;{amod.keyDownDiv(ev)});\n</code></pre></p> <p>If using <code>twr_iocanvas</code> <pre><code>document.getElementById(\"twr_iocanvas\").addEventListener(\"keydown\",(ev)=&gt;{amod.keyDownCanvas(ev)});\n</code></pre></p> <p>You likely want a line like this to automatically set the focus to the div or canvas element (so the user doesn't have to click on the element to manually set focus.  Key events are sent to the element with focus.):</p> <pre><code>document.getElementById(\"twr_iocanvas\").focus();\n</code></pre> <p>You will also need to set the tabindex attribute in your div tag like this:</p> <pre><code>&lt;div id=\"twr_iodiv\" tabindex=\"0\"&gt;&lt;/div&gt;\n</code></pre> <p>See the stdio-div and stdio-canvas examples.</p>"},{"location":"gettingstarted/stdio/#sending-asyncronous-events-to-wasm-functions","title":"Sending asyncronous  events to Wasm functions","text":"<p>Note that this section describes blocking input using stdin.  As an alternative, you can send events (keyboard, mouse, timer, etc) to a non-blocking C function from JavaScript using <code>callC</code>.  See the <code>balls</code> example.</p>"},{"location":"more/building/","title":"Building the twr-wasm Source","text":""},{"location":"more/building/#source-for-twr-wasm","title":"Source for twr-wasm","text":"<p>The source can be found at:</p> <pre><code>https://github.com/twiddlingbits/twr-wasm\n</code></pre> <p>The <code>main</code> branch contains the latest release.  The <code>dev</code> branch is work in progress.</p>"},{"location":"more/building/#tools-needed-to-build-twr-wasm-source","title":"Tools Needed to Build twr-wasm Source","text":"<p>You will need these core tools:</p> <ul> <li>TypeScript</li> <li>clang tool chain - for C/C++ code</li> <li>wasm-ld - to link the .wasm files</li> <li>wat2wasm - to compile WebAssembly (.wat) files of which I have a few </li> <li>GNU make</li> <li>git - to clone twr-wasm source, or to clone llvm, if you want to build libc++</li> </ul> <p>In addition, you might need:</p> <ul> <li>VS Code - to use the debug launcher and build tasks</li> <li>NPM - package manager</li> <li>Parcel v2 - to bundle the examples</li> <li>mkdocs, material theme, meta-descriptions plugin - to build the documentation static web site</li> <li>python - mkdocs is built with python, and you need python to run server.py in examples</li> <li>CMake and ninja - to build llvm libc++</li> </ul> <p>There is a deprecated gcc build that I used to use for testing, but now the tests are executed in wasm.</p>"},{"location":"more/building/#to-build-the-libraries-lib-c-lib-js","title":"To Build the Libraries (lib-c, lib-js)","text":"<p><pre><code>cd source\nmake\n</code></pre> or on windows <pre><code>cd source\nmingw32-make\n</code></pre></p>"},{"location":"more/building/#to-build-the-examples","title":"To Build the Examples","text":"<p>See examples/readme.md for more information.</p> <p>To build the examples, but not bundle them.  <pre><code>cd examples\nsh buildall.sh\n</code></pre></p> <p>To build bundles: <pre><code>sh buildbundles.sh\n</code></pre></p>"},{"location":"more/building/#to-build-the-docs","title":"To Build the docs","text":"<p>The docs are created using the material theme for mkdocs.</p> <p>In twr-wasm root folder:</p> <pre><code>mkdocs build\n</code></pre> <p>The destination of the build is found in the <code>mkdocs.yml</code> file (<code>site_dir: azure/docsite/</code>).</p> <p>Usually the docs are built as part of building the static web site that hosts the docs and examples.  This is accomplished using this shell script (found in examples folder): <pre><code>buildazure.sh\n</code></pre></p>"},{"location":"more/building/#to-build-libc-for-wasm-and-twr-wasm","title":"To Build libc++ for Wasm and twr-wasm","text":"<p>See the instructions in the comments in the shell script <code>source\\libcxx\\buildlibcxx.sh</code></p>"},{"location":"more/building/#installing-clang-and-wasm-ld-on-windows","title":"Installing clang and wasm-ld on Windows","text":"<p>Here is how I installed the tools for windows: </p> <pre><code> install  MSYS2 \n   1. https://www.msys2.org/\n   2. After the install completes, run UCRT64 terminal by clicking on the MSYS2 UCRT64 in the Start menu\n   3. pacman -Syuu\n\n install gcc using MSYS2 UCRT64\n   1. Use MSYS2 UCRT64 terminal (per above)\n   1. pacman -S mingw-w64-ucrt-x86_64-toolchain\n\n install clang and wasm-ld using MSYS2 UCRT64\n   2. Use MSYS2 UCRT64  (per above)\n      1. pacman -S mingw-w64-ucrt-x86_64-clang\n      2. pacman -S mingw-w64-x86_64-lld\n\nupdate PATH env variable using the windows control panel (search for path)\n   2. added C:\\msys64\\ucrt64\\bin \n   3. added C:\\msys64\\mingw64\\bin \n   4. added C:\\msys64\\usr\\bin (for sh.exe used by mingw32-make)\n</code></pre> <p>wabt tools:  can be found here https://github.com/WebAssembly/wabt/releases </p>"},{"location":"more/debugging/","title":"Debugging WebAssembly","text":"<p>This section describes some tips for debugging your WebAssembly (Wasm) program.  Some of these techniques are WebAssembly generic, some are specific to using twr-wasm.</p>"},{"location":"more/debugging/#debug-and-release-libraries","title":"Debug and Release libraries","text":"<p>There are release (twr.a) and debug (twrd.a) versions of the twr-wasm C library.  See the examples for uses of both.  The \"debug\" version has debug symbols enabled and is built with <code>-O0</code>.  The \"release\" version has no debug symbols and optimization is set to <code>-O3</code>.  Both have asserts enabled.  In general, you should use the \"release\" version unless you wish to step through the twr-wasm source -- in which case use the \"debug\" version.</p> <p>libc++.a is not built with debug symbols.</p>"},{"location":"more/debugging/#source-level-debugging-webassembly-cc","title":"Source Level Debugging WebAssembly C/C++","text":"<p>In order to enable C/C++ source debugging with Wasm and clang, do the following:</p> <ol> <li>Use Chrome</li> <li>Install the Chrome extension: C/C++ DevTools Support (DWARF) ( https://chromewebstore.google.com/detail/pdcpmagijalfljmkmjngeonclgbbannb )</li> <li>Use the clang compile flag -g to add debug annotation to your object files</li> <li>You may want to turn off optimization to allow the debugger to have a bit more logical behavior (remove the -O flag or set to -O0) </li> <li>You may want to use the version of the twr-wasm C library that has debug symbols enabled (twrd.a).  Only if you want to step into the twrd.a source.</li> <li>You need to serve your files with a (likely local) web server.  For example, 'python server.py' is provided.  'server.py' can be found in the examples root folder.  Note that your local server needs to enable SharedArrayBuffers if you are using <code>twrWasmModuleAsync</code> -- see the server.py example.</li> <li>your code can be bundled or unbundled, but</li> <li>you need to ensure that the web server/browser can find the source code</li> <li>also see Example Readme</li> </ol>"},{"location":"more/debugging/#useful-twr-wasm-debug-functions","title":"Useful twr-wasm Debug Functions","text":"<p>Use <code>twr_conlog</code> to print to the JavaScript console from C (see API ref section). <pre><code>#include \"twr-wasm.h\"\n\ntwr_conlog(\"hello 99 in hex: %x\",99);\n</code></pre></p> <p>Use <code>twrWasmModule.divLog()</code> to print to a div inside JavaScript code (see API ref section).</p>"},{"location":"more/debugging/#testing-webassembly-without-a-web-server","title":"Testing WebAssembly Without a Web Server","text":"<p>Note: If you use this technique, you will not be able to get the C/C++ DevTool chrome extension to run, and so source level debugging won't work. (If you know how to fix this, please contact me on github.)</p> <p>You can execute and debug JavaScript with Wasm from local files without an HTTP server.  It might be helpful to download the twr-wasm source code from github when you do this (so you can step through the twr-wasm typescript code as needed).</p> <p>See the examples and Example Readme for more detail on how this works.</p> <p>In general, you will need to add a clip of code similar to this to your HTML: <pre><code>&lt;script type=\"importmap\"&gt;\n   {\n      \"imports\": {\n      \"twr-wasm\": \"./../../lib-js/index.js\"\n      }\n   }\n&lt;/script&gt;\n</code></pre></p> <p>Make sure the paths to  <code>twr-wasm/lib-js/index.js</code> are correct for where your source is located.  The above is correct for the provided examples.</p> <p>You will need to set the following flags when running chrome from the shell or VS Code (the first is only strictly required if using twrWasmModuleAsync).</p> <pre><code>--enable-features=SharedArrayBuffer\n--allow-file-access-from-files\n</code></pre> <p>If you are using VS Code, You can create a launch.json entry similar to this:</p> launch.json<pre><code>{\n    \"configurations\": [\n    {\n        \"name\": \"Launch Chrome\",\n        \"request\": \"launch\",\n        \"type\": \"chrome\",\n        \"runtimeArgs\": [\n            \"--allow-file-access-from-files\",\n            \"--autoplay-policy=no-user-gesture-required\",\n            \"--enable-features=SharedArrayBuffer\"\n         ],\n         \"file\": \"${workspaceFolder}/index.html\",\n         \"cwd\": \"${workspaceFolder}/\",\n    }\n    ]\n}\n</code></pre>"},{"location":"more/production/","title":"CORS headers needed to use twrWasmModuleAsync","text":"<p>Important Production Note</p> <p>twr-wasm class <code>twrWasmModuleAsync</code> uses <code>SharedArrayBuffers</code>, and there are special CORS headers that need to be configured to use <code>SharedArrayBuffers</code>, that are not widely enabled by default on web servers.  The server.py or staticwebapp.config.json examples show which headers to set (also see the <code>SharedArrayBuffer</code> documentation online).  </p>"},{"location":"more/wasm-problem/","title":"Wasm Runtime Limitations","text":"<p>HTML browsers can load a WebAssembly module, and execute it's bytecode in a browser virtual machine.  You compile your code using clang with the target code format being WebAssembly (wasm) byte code.   There are a few issues that one immediately encounters trying to execute code that is more complicated than squaring a number.  </p> <p>The first is that there is no C/C++ runtime support native to a WebAssembly module.  That is, no malloc or printf or similar functions.  Even beyond than that, there are missing compiler support functions.  That is, clang code generation will produce calls for compiler support routines needed for floating point, memcpy, and the like.   This code is usually handled behind the scenes for you.  For example, gcc will link to \"libgcc\" automatically.  clang uses \"compile-rt\".  This doesn't happen with WebAssembly compiles (unless you use emscripten or twr-wasm).</p> <p>The second problem is that all the function calls between your Wasm module and your javascript are limited to parameters and return values that are numbers (integer and float). No strings, arrays, struct pointers, etc.</p> <p>The third problem is that legacy C code or games often block, and when written this way they don't naturally integrate with the JavaScript asynchronous programming model.</p> <p>twr-wasm is a static C library (twr.a) that you can link to your clang C/C++ code, as well as a set of JavaScript/TypeScript modules that solve these issues.</p>"}]}